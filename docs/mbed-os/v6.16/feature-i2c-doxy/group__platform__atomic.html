<!DOCTYPE html>
<html>
    
<!-- Mirrored from os.mbed.com/docs/mbed-os/v6.16/feature-i2c-doxy/group__platform__atomic.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 16 Sep 2024 16:01:04 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
        
        <meta charset="utf-8"/>
        <title>Mbed OS Reference | atomic functions</title>
        <link href="../static/css/vendor/foundation-6.2.4.min.mbed-cache-4c48f6c816971070eb1e4eca75f0ec30.css" rel="stylesheet"/>
        <link href="search/search.css" rel="stylesheet"/>
        <link href="../static/css/app.mbed-cache-a44289fe9f5ca07036a335d6ad7ed8ad.css" rel="stylesheet"/>
        <script src="../static/js/vendor/jquery-3.2.1.min.mbed-cache-c9f5aeeca3ad37bf2aa006139b935f0a.js"></script>
        <script src="dynsections.js"></script>
        <script src="search/searchdata.js"></script>
        <script src="search/search.js"></script>
        <script>
            $(document).ready(function() {
                init_search();
            });
        </script>
    
        

<!-- Google Analytics -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','../../../../../www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-1447836-8');
ga('require', 'GTM-WXMLD4S')
</script>

<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'../../../../../www.googletagmanager.com/gtm5445.html?id='+i+dl+'&gtm_auth=SMYNPwM0ICsV00c1ZHETqQ&gtm_preview=env-2&gtm_cookies_win=x';f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-M6FZ495');</script>


    <script>
    (function(h,o,t,j,a,r){
        h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};
        h._hjSettings={hjid:971746,hjsv:6};
        a=o.getElementsByTagName('head')[0];
        r=o.createElement('script');r.async=1;
        r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;
        a.appendChild(r);
    })(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');
</script>



<!-- Favicons -->
<link rel="apple-touch-icon" sizes="57x57" href="../../../../static/img/favicons/apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../../../static/img/favicons/apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../../../static/img/favicons/apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../../../static/img/favicons/apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../../../static/img/favicons/apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../../../static/img/favicons/apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../../../../static/img/favicons/apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../../../../static/img/favicons/apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../../../../static/img/favicons/apple-icon-180x180.png">
<link rel="icon" type="image/png" sizes="192x192"  href="../../../../static/img/favicons/android-icon-192x192.png">
<link rel="icon" type="image/png" sizes="32x32" href="../../../../static/img/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="../../../../static/img/favicons/favicon-96x96.png">
<link rel="icon" type="image/png" sizes="16x16" href="../../../../static/img/favicons/favicon-16x16.png">
<link rel="manifest" href="https://os.mbed.com/static/img/favicons/manifest.json">
<link rel="shortcut icon" href="https://os.mbed.com/static/img/favicon.ico?">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="/static/img/favicons/ms-icon-144x144.png">
<meta name="theme-color" content="#ffffff">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,400,700">

<link rel="stylesheet" href="../../../../static/CACHE/css/output.811e2930ab34.css" type="text/css">

<link href="../../../../static/docs/css/doc_viewer.css" rel="stylesheet">
<link href="../../../../static/fonts.css" rel="stylesheet">
<link href="../../../../static/docs-nav-and-footer1b26.css?v2" rel="stylesheet">


<link rel="canonical" href="group__platform__atomic.html">
<script src="../../../../static/mbed-nav-vertical-menu.js"></script>


    </head>
    <body>
        








<div class="mbed-nav">
    <div class="mbed-nav__mobile-menu-control">
        <i class="mbed-nav__mobile-menu-control-open fas fa-bars fa-fw"></i>
        <i class="mbed-nav__mobile-menu-control-close fas fa-times is-hidden fa-fw"></i>
        <i class="mbed-nav__mobile-menu-control-back fas fa-angle-left is-hidden fa-fw"></i>
    </div>
    <div class="mbed-nav__logo">
        <a href="https://os.mbed.com/">
            <svg><use xlink:href="https://os.mbed.com/static/img/mbed_nav_spritesheet.8ac20221a123.svg?v3#logo"></use></svg>
        </a>
    </div>
    <div class="mbed-nav__menu">

        <!-- Main menu -->
        <nav class="mbed-nav__main-menu">
            <ul class="mbed-nav__dropdown-menu">
                <li class="has-dropdown">
                    Overview

                    <div class="mbed-nav__dropdown-menu-content">

                        <!-- Overview dropdown menu -->
                        <div class="mbed-nav__overview-menu">
                            <section>
                                <p>Operating system</p>
                                <ul>
                                    <li>
                                        <a href="https://os.mbed.com/mbed-os/" class="mbed-nav__icon-link-detail">
                                            <svg><use xlink:href="https://os.mbed.com/static/img/mbed_nav_spritesheet.8ac20221a123.svg?v3#mbed_os"></use></svg>
                                            <div>
                                                <p>Mbed OS</p>
                                                <p>The open source OS for Cortex-M devices</p>
                                            </div>
                                        </a>
                                    </li>
                                </ul>
                            </section>

                            <section>
                                <p>Development tools</p>
                                <ul>
                                    <li>
                                        <a href="https://www.keil.arm.com/mbed/?utm_source=mbed_com&amp;utm_medium=compiler_button&amp;utm_campaign=mbed_com_promo" class="mbed-nav__icon-link-detail">
                                             <svg><use href="https://os.mbed.com/static/img/keil_studio_icon.2c56c28014c6.svg?#keil_studio_icon"></use></svg>
                                            <div>
                                                <p>Keil Studio Cloud</p>
                                                <p>Arm's IDE for IoT, embedded and Mbed development</p>
                                            </div>
                                         </a>
                                     </li>
                                    <li>
                                        <a href="https://os.mbed.com/studio/" class="mbed-nav__icon-link-detail">
                                            <svg><use xlink:href="https://os.mbed.com/static/img/mbed_nav_spritesheet.8ac20221a123.svg?v3#mbed_studio"></use></svg>
                                            <div>
                                                <p>Mbed Studio</p>
                                                <p>Download the desktop IDE for Mbed OS</p>
                                            </div>
                                        </a>
                                    </li>
                                    <li>
                                        <a href="https://os.mbed.com/docs/mbed-os/latest/quick-start/offline-with-mbed-cli.html" class="mbed-nav__icon-link-detail">

                                            <svg><use xlink:href="https://os.mbed.com/static/img/mbed_nav_spritesheet.8ac20221a123.svg?v3#mbed_cli"></use></svg>
                                            <div>
                                               <p>Mbed CLI</p>
                                               <p>Command line access to Mbed tools and services</p>
                                            </div>
                                        </a>
                                    </li>
                                </ul>
                            </section>

                            <section>
                                <p>Security and Connectivity</p>
                                <ul>
                                    <li>
                                        <a href="https://tls.mbed.org/" class="mbed-nav__icon-link-detail">
                                            <svg><use xlink:href="https://os.mbed.com/static/img/mbed_nav_spritesheet.8ac20221a123.svg?v3#mbed_tls_crypto"></use></svg>
                                            <div>
                                                <p>Mbed TLS and Mbed Crypto</p>
                                                <p>Industry standard TLS stack and crypto library</p>
                                            </div>
                                        </a>
                                    </li>
                                    <li>
                                        <a href="https://os.mbed.com/connectivity-technologies/" class="mbed-nav__icon-link-detail">
                                            <svg><use xlink:href="https://os.mbed.com/static/img/mbed_nav_spritesheet.8ac20221a123.svg?v3#connectivity"></use></svg>
                                            <div>
                                                <p>Connectivity</p>
                                                <p>BLE, WiFi, Cellular, LoRaWAN and more</p>
                                            </div>
                                        </a>
                                    </li>
                                </ul>
                            </section>
                        </div>
                    </div>
                </li>
                <li class="has-dropdown">
                    Hardware

                    <!-- Hardware dropdown menu -->
                    <div class="mbed-nav__dropdown-menu-content">
                        <div class="mbed-nav__hardware-dropdown">
                            <ul class="mbed-nav__hardware-menu">
                                <li>
                                    <a href="https://os.mbed.com/platforms/" class="mbed-nav__icon-link-detail">
                                        <svg><use xlink:href="https://os.mbed.com/static/img/mbed_nav_spritesheet.8ac20221a123.svg?v3#boards"></use></svg>
                                        <div>
                                            <p>Boards</p>
                                            <p>Build your Mbed projects with development boards for Arm Cortex processors and MCUs</p>
                                        </div>
                                    </a>
                                </li>
                                <li>
                                    <a href="https://os.mbed.com/modules/" class="mbed-nav__icon-link-detail">
                                        <svg><use xlink:href="https://os.mbed.com/static/img/mbed_nav_spritesheet.8ac20221a123.svg?v3#modules"></use></svg>
                                        <div>
                                            <p>Modules</p>
                                            <p>Modules include a MCU, connectivity and onboard memory, making them ideal for designing IoT products for mass production</p>
                                        </div>
                                    </a>
                                </li>
                                <li>
                                    <a href="https://os.mbed.com/components/" class="mbed-nav__icon-link-detail">
                                        <svg><use xlink:href="https://os.mbed.com/static/img/mbed_nav_spritesheet.8ac20221a123.svg?v3#components"></use></svg>
                                        <div>
                                            <p>Components</p>
                                            <p>The component database hosts libraries for different sensors, actuators, radios, inputs, middleware and IoT services</p>
                                        </div>
                                    </a>
                                </li>
                                <li>
                                    <a href="https://os.mbed.com/hardware/" class="mbed-nav__icon-link-detail">
                                        <svg><use xlink:href="https://os.mbed.com/static/img/mbed_nav_spritesheet.8ac20221a123.svg?v3#hardware_overview"></use></svg>
                                        <div>
                                            <p>Hardware overview & Mbed Enabled</p>
                                            <p>Learn about hardware support for Mbed, as well as the Mbed Enabled program, which identifies Mbed compatible products</p>
                                        </div>
                                    </a>
                                </li>
                                <li>
                                    <a href="https://os.mbed.com/docs/mbed-os/latest/porting/arm-mbed-hdk.html" class="mbed-nav__icon-link-detail">
                                        <svg><use xlink:href="https://os.mbed.com/static/img/mbed_nav_spritesheet.8ac20221a123.svg?v3#mbed_hdk"></use></svg>
                                        <div>
                                            <p>Mbed HDK</p>
                                            <p>Reference designs, schematics and board layouts to develop production hardware and Mbed-compatible development boards</p>
                                        </div>
                                    </a>
                                </li>
                            </ul>
                        </div>
                    </div>

                </li>
                <li><a href="https://os.mbed.com/code/">Code</a></li>
                <li class="has-dropdown">
                    Documentation

                    <!-- Documentation dropdown menu -->
                    <div class="mbed-nav__dropdown-menu-content">
                        <div class="mbed-nav__documentation-dropdown">
                            <ul class="mbed-nav__documentation-menu">
                                <li>
                                    <a href="https://os.mbed.com/docs/mbed-os/">Mbed OS</a>
                                </li>
                                <li>
                                    <a
                                        href="https://developer.arm.com/documentation/102497/latest/Arm-Keil-Studio-Cloud">
                                        Keil Studio
                                    </a>
                                </li>
                                <li>
                                    <a href="https://os.mbed.com/docs/mbed-studio/">Mbed Studio</a>
                                </li>
                            </ul>
                        </div>
                    </div>
                </li>
                <li><a href="https://os.mbed.com/built-with-mbed/">Case studies</a></li>
                <li class="has-dropdown">
                    Community

                    <!-- Community dropdown menu -->
                    <div class="mbed-nav__dropdown-menu-content">
                        <div class="mbed-nav__community-dropdown">
                            <ul class="mbed-nav__community-menu">
                                <li>
                                    <a href="https://forums.mbed.com/">Forum</a>
                                </li>
                                <li>
                                    <a href="https://os.mbed.com/docs/mbed-os/latest/contributing/index.html">Contribute</a>
                                </li>
                                <li>
                                    <a href="https://www.youtube.com/playlist?list=PLKjl7IFAwc4R4plIZe4IuHlsn8zW7rvKh">Mbed OS Tech Forum</a>
                                </li>
                                <li>
                                    <a href="https://os.mbed.com/support/">Report a problem</a>
                                </li>
                            </ul>
                        </div>
                    </div>
                </li>
                <li>
                    <a href="https://os.mbed.com/blog/">Blog</a>
                </li>
            </ul>
        </nav>
    </div>
    <div class="mbed-nav__user-controls">
        <div class="mbed-nav__user-controls-top">
            <div class="mbed-nav__search">
                <form id="mbed-nav__search-box" class="is-hidden" action="https://os.mbed.com/search" method="GET">
                    <div class="mbed-nav__search-box">
                        <input type="search" name="q" placeholder="Search...">
                        <button type="submit">
                            <svg class="stroke-white"><use xlink:href="https://os.mbed.com/static/img/mbed_nav_spritesheet.8ac20221a123.svg?v3#search"></use></svg>
                        </button>
                    </div>
                </form>
                <i class="mbed-nav__search-close fas fa-times is-hidden"></i>
                <svg class="mbed-nav__search-open stroke-white"><use xlink:href="https://os.mbed.com/static/img/mbed_nav_spritesheet.8ac20221a123.svg?v3#search"></use></svg>
            </div>
            <a class="mbed-nav__cta" href="https://studio.keil.arm.com/mbed" target="_blank">
                Keil Studio Cloud
            </a>

            
                
                <nav class="mbed-nav__logged-out-nav">
                    <ul class="mbed-nav__dropdown-menu">
                        <li>
                            <svg class="stroke-white"><use xlink:href="https://os.mbed.com/static/img/mbed_nav_spritesheet.8ac20221a123.svg?v3#profile"></use></svg>

                            <!-- Logged out dropdown menu -->
                            <div class="mbed-nav__dropdown-menu-content">
                                <div class="mbed-nav__logged-out-dropdown">
                                    <ul class="mbed-nav__logged-out-menu">
                                        <li><a href="https://os.mbed.com/account/login/?next=/docs/mbed-os/v6.16/feature-i2c-doxy/group__platform__atomic.html">Log in or Sign up</a></li>
                                    </ul>
                                </div>
                            </div>
                        </li>
                    </ul>
                </nav>
                
            
        </div>
    </div>
    <div class="mbed-nav__spacer"></div>
</div>
<div class="mbed-nav__mobile-menu-cover is-hidden">
    <div class="mbed-nav__mobile-menu">

        <div id="mbed-nav__main-menu-mobile">
            <div class="mbed-nav__user-controls-mobile">
                <div class="mbed-nav__user-controls-top-mobile">
                    <form action="https://os.mbed.com/search" method="GET">
                        <div class="mbed-nav__search-box mbed-nav__search-box--light">
                            <input type="search" name="q" placeholder="Search...">
                            <button type="submit">
                                <svg class="stroke-dark-grey"><use xlink:href="https://os.mbed.com/static/img/mbed_nav_spritesheet.8ac20221a123.svg?v3#search"></use></svg>
                            </button>
                        </div>
                    </form>
                    
                        
                        <a href="https://os.mbed.com/account/login/?next=/docs/mbed-os/v6.16/feature-i2c-doxy/group__platform__atomic.html">Log in or Sign up</a>
                        
                    
                </div>
            </div>

            <ul class="mbed-nav__side-menu">
                <li>
                    <input type="checkbox" name="accordion-toggle" id="overview-accordion">
                    <label for="overview-accordion">Overview</label>
                    <div class="accordion_content">
                        <ul class="overview-menu-mobile">
                            <li>
                                <p>Operating system</p>
                                <ul>
                                    <li>
                                        <a href="https://os.mbed.com/mbed-os/" class="mbed-nav__icon-link">
                                            <svg><use xlink:href="https://os.mbed.com/static/img/mbed_nav_spritesheet.8ac20221a123.svg?v3#mbed_os"></use></svg>
                                            <p>Mbed OS</p>
                                        </a>
                                    </li>
                                    

                                </ul>
                            </li>
                            <li>
                                <p>Development tools</p>
                                <ul>
                                    <li>
                                        <a href="https://os.mbed.com/studio/" class="mbed-nav__icon-link">
                                            <svg><use xlink:href="https://os.mbed.com/static/img/mbed_nav_spritesheet.8ac20221a123.svg?v3#mbed_studio"></use></svg>
                                            <p>Mbed Studio</p>
                                        </a>
                                    </li>
                                    <li>
                                        <a href="https://www.keil.arm.com/mbed/?utm_source=mbed_com&amp;utm_medium=compiler_button&amp;utm_campaign=mbed_com_promo" class="mbed-nav__icon-link">
                                             <svg><use href="https://os.mbed.com/static/img/keil_studio_icon.2c56c28014c6.svg?#keil_studio_icon"></use></svg>
                                            <p>Keil Studio</p>
                                        </a>
                                    </li>
                                    <li>
                                        <a href="https://os.mbed.com/docs/mbed-os/latest/quick-start/offline-with-mbed-cli.html" class="mbed-nav__icon-link">
                                            <svg><use xlink:href="https://os.mbed.com/static/img/mbed_nav_spritesheet.8ac20221a123.svg?v3#mbed_cli"></use></svg>
                                            <p>Mbed CLI</p>
                                        </a>
                                    </li>
                                </ul>
                            </li>
                            <li>
                                <p>Security and connectivity</p>
                                <ul>
                                    <li>
                                        <a href="https://tls.mbed.org/" class="mbed-nav__icon-link">
                                            <svg><use xlink:href="https://os.mbed.com/static/img/mbed_nav_spritesheet.8ac20221a123.svg?v3#mbed_tls_crypto"></use></svg>
                                            <p>Mbed TLS and Mbed Crypto</p>
                                        </a>
                                    </li>
                                    <li>
                                        <a href="https://os.mbed.com/connectivity-technologies/" class="mbed-nav__icon-link">
                                            <svg><use xlink:href="https://os.mbed.com/static/img/mbed_nav_spritesheet.8ac20221a123.svg?v3#connectivity"></use></svg>
                                            <p>Connectivity</p>
                                        </a>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </li>
                <li>
                    <input type="checkbox" name="accordion-toggle" id="hardware-accordion">
                    <label for="hardware-accordion">Hardware</label>
                    <div class="accordion_content">
                        <ul>
                            <li>
                                <a href="https://os.mbed.com/platforms/" class="mbed-nav__icon-link">
                                    <svg><use xlink:href="https://os.mbed.com/static/img/mbed_nav_spritesheet.8ac20221a123.svg?v3#boards"></use></svg>
                                    <p>Boards</p>
                                </a>
                            </li>
                            <li>
                                <a href="https://os.mbed.com/modules/" class="mbed-nav__icon-link">
                                    <svg><use xlink:href="https://os.mbed.com/static/img/mbed_nav_spritesheet.8ac20221a123.svg?v3#modules"></use></svg>
                                    <p>Modules</p>
                                </a>
                            </li>
                            <li>
                                <a href="https://os.mbed.com/components/" class="mbed-nav__icon-link">
                                    <svg><use xlink:href="https://os.mbed.com/static/img/mbed_nav_spritesheet.8ac20221a123.svg?v3#components"></use></svg>
                                    <p>Components</p>
                                </a>
                            </li>
                            <li>
                                <a href="https://os.mbed.com/hardware/" class="mbed-nav__icon-link">
                                    <svg><use xlink:href="https://os.mbed.com/static/img/mbed_nav_spritesheet.8ac20221a123.svg?v3#hardware_overview"></use></svg>
                                    <p>Hardware overview & Mbed Enabled</p>
                                </a>
                            </li>
                            <li>
                                <a href="https://os.mbed.com/docs/mbed-os/latest/porting/arm-mbed-hdk.html" class="mbed-nav__icon-link">
                                    <svg><use xlink:href="https://os.mbed.com/static/img/mbed_nav_spritesheet.8ac20221a123.svg?v3#mbed_hdk"></use></svg>
                                    <p>Mbed HDK</p>
                                </a>
                            </li>
                        </ul>
                    </div>
                </li>
                <li><a href="https://os.mbed.com/code/">Code</a></li>
                <li>
                    <input type="checkbox" name="accordion-toggle" id="documentation-accordion">
                    <label for="documentation-accordion">Documentation</label>
                    <div class="accordion_content">
                        <ul>
                            <li><a href="https://os.mbed.com/docs/mbed-os/">Mbed OS</a></li>
                            <li><a href="https://os.mbed.com/docs/mbed-studio/">Mbed Studio</a></li>
                            <li>
                              <a
                                href="https://developer.arm.com/documentation/102497/1-5/Arm-Keil-Studio/?utm_source=mbed_com&amp;utm_medium=nav_docs_link&amp;utm_campaign=mbed_com_promo">
                                Keil Studio
                              </a>
                            </li>
                        </ul>
                    </div>
                </li>
                <li><a href="https://os.mbed.com/built-with-mbed/">Case studies</a></li>
                <li>
                    <input type="checkbox" name="accordion-toggle" id="community-accordion">
                    <label for="community-accordion">Community</label>
                    <div class="accordion_content">
                        <ul>
                            <li><a href="https://forums.mbed.com/">Forum</a></li>
                            <li><a href="https://os.mbed.com/docs/mbed-os/latest/contributing/index.html">Contribute</a></li>
                            <li><a href="https://www.youtube.com/playlist?list=PLKjl7IFAwc4R4plIZe4IuHlsn8zW7rvKh">Mbed OS Tech Forum</a></li>
                            <li><a href="https://os.mbed.com/support/">Report a problem</a></li>
                        </ul>
                    </div>
                </li>
                <li><a href="https://os.mbed.com/blog/">Blog</a></li>
            </ul>
        </div>

        
    </div>
</div>



<div class="version-picker-container">
    
    <select class="version-picker" onchange="goToVersion(this.value)">
        
            <option
                value="v6.16"
                selected
            >
                v6.16
            </option>
        
            <option
                value="v6.15"
                
            >
                v6.15
            </option>
        
            <option
                value="v6.14"
                
            >
                v6.14
            </option>
        
            <option
                value="v6.13"
                
            >
                v6.13
            </option>
        
            <option
                value="v6.12"
                
            >
                v6.12
            </option>
        
            <option
                value="v6.11"
                
            >
                v6.11
            </option>
        
            <option
                value="v6.10"
                
            >
                v6.10
            </option>
        
            <option
                value="v6.9"
                
            >
                v6.9
            </option>
        
            <option
                value="v6.8"
                
            >
                v6.8
            </option>
        
            <option
                value="v6.7"
                
            >
                v6.7
            </option>
        
            <option
                value="v6.6"
                
            >
                v6.6
            </option>
        
            <option
                value="v6.5"
                
            >
                v6.5
            </option>
        
            <option
                value="v5.15"
                
            >
                v5.15
            </option>
        
    </select>
    

    <div class="contact-us">
        Mistake on this page?
        
            <br>
            <a href="https://github.com/ARMmbed/mbed-os-5-docs/issues">
                Report an issue in GitHub
                <i class="fab fa-github"></i>
            </a>
            or
            <a href="mailto:mbed-support@arm.com">
                email us
                <i class="fas fa-envelope"></i>
            </a>
        
    </div>
</div>

<script>
    function goToVersion(version) {
        window.location.href = window.location.href.replace(
            "v6.16",
            version
        )
    }
</script>

        
        <div class="topbar" id="top">
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div class="tabs" id="navrow1">
    <ul class="tablist">
      <li><a href="index.html"><span>Main Page</span></a></li>
      <li><a href="pages.html"><span>Related Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div class="MSearchBoxInactive" id="MSearchBox">
        <span class="left">
          <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png"/>
          <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search"/>
          </span><span class="right">
            <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png"/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> |
<a href="#define-members">Macros</a> |
<a href="#typedef-members">Typedefs</a> |
<a href="#enum-members">Enumerations</a> |
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">atomic functions<div class="ingroups"><a class="el" href="group__mbed-os-public.html">Public API</a> » <a class="el" href="group__platform-public-api.html">Platform</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Atomic functions function analogously to C11 and C++11 - loads have acquire semantics, stores have release semantics, and atomic operations are sequentially consistent.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">A lock-free, primitive atomic flag.  <a href="structcore__util__atomic__flag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa8f56a572a9d71e864311c431ee1131a"><td align="right" class="memItemLeft" valign="top">#define </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaa8f56a572a9d71e864311c431ee1131a">CORE_UTIL_ATOMIC_FLAG_INIT</a>   { 0 }</td></tr>
<tr class="memdesc:gaa8f56a572a9d71e864311c431ee1131a"><td class="mdescLeft"> </td><td class="mdescRight">Initializer for a <a class="el" href="structcore__util__atomic__flag.html" title="A lock-free, primitive atomic flag. ">core_util_atomic_flag</a>.  <a href="#gaa8f56a572a9d71e864311c431ee1131a">More...</a><br/></td></tr>
<tr class="separator:gaa8f56a572a9d71e864311c431ee1131a"><td class="memSeparator" colspan="2"> </td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga7b145797819135b3b0fff65764f8f234"><td align="right" class="memItemLeft" valign="top">typedef enum <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga7b145797819135b3b0fff65764f8f234">mbed_memory_order</a></td></tr>
<tr class="memdesc:ga7b145797819135b3b0fff65764f8f234"><td class="mdescLeft"> </td><td class="mdescRight">Memory order constraints for atomic operations.  <a href="#ga7b145797819135b3b0fff65764f8f234">More...</a><br/></td></tr>
<tr class="separator:ga7b145797819135b3b0fff65764f8f234"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga1060896cc90d691abb7e862cedcdc1b2"><td align="right" class="memItemLeft" valign="top">typedef struct <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga1060896cc90d691abb7e862cedcdc1b2">core_util_atomic_flag</a></td></tr>
<tr class="memdesc:ga1060896cc90d691abb7e862cedcdc1b2"><td class="mdescLeft"> </td><td class="mdescRight">A lock-free, primitive atomic flag.  <a href="#ga1060896cc90d691abb7e862cedcdc1b2">More...</a><br/></td></tr>
<tr class="separator:ga1060896cc90d691abb7e862cedcdc1b2"><td class="memSeparator" colspan="2"> </td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga38d0898d94b33af23bbbb56e358cdbdf"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga38d0898d94b33af23bbbb56e358cdbdf">core_util_atomic_flag_test_and_set</a> (volatile <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a> *flagPtr)</td></tr>
<tr class="memdesc:ga38d0898d94b33af23bbbb56e358cdbdf"><td class="mdescLeft"> </td><td class="mdescRight">Atomic test and set.  <a href="#ga38d0898d94b33af23bbbb56e358cdbdf">More...</a><br/></td></tr>
<tr class="separator:ga38d0898d94b33af23bbbb56e358cdbdf"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gae873e0a5133bece10fa16b29c43ecc34"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gae873e0a5133bece10fa16b29c43ecc34">core_util_atomic_flag_test_and_set_explicit</a> (volatile <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a> *valuePtr, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gae873e0a5133bece10fa16b29c43ecc34"><td class="mdescLeft"> </td><td class="mdescRight">\ copydoc core_util_atomic_flag_test_and_set  <a href="#gae873e0a5133bece10fa16b29c43ecc34">More...</a><br/></td></tr>
<tr class="separator:gae873e0a5133bece10fa16b29c43ecc34"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gafe5e3f9d2bd9cf92276dacdc3928f4f0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gafe5e3f9d2bd9cf92276dacdc3928f4f0">core_util_atomic_flag_clear</a> (volatile <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a> *flagPtr)</td></tr>
<tr class="memdesc:gafe5e3f9d2bd9cf92276dacdc3928f4f0"><td class="mdescLeft"> </td><td class="mdescRight">Atomic clear.  <a href="#gafe5e3f9d2bd9cf92276dacdc3928f4f0">More...</a><br/></td></tr>
<tr class="separator:gafe5e3f9d2bd9cf92276dacdc3928f4f0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaa1918431bfda711a76ff391ae95f7cdd"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaa1918431bfda711a76ff391ae95f7cdd">core_util_atomic_flag_clear_explicit</a> (volatile <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a> *flagPtr, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gaa1918431bfda711a76ff391ae95f7cdd"><td class="mdescLeft"> </td><td class="mdescRight">\ copydoc core_util_atomic_flag_clear  <a href="#gaa1918431bfda711a76ff391ae95f7cdd">More...</a><br/></td></tr>
<tr class="separator:gaa1918431bfda711a76ff391ae95f7cdd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga3c9ab0fa7ce3b902356e10951e622198"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga3c9ab0fa7ce3b902356e10951e622198">core_util_atomic_cas_u8</a> (volatile uint8_t *ptr, uint8_t *expectedCurrentValue, uint8_t desiredValue)</td></tr>
<tr class="memdesc:ga3c9ab0fa7ce3b902356e10951e622198"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#ga3c9ab0fa7ce3b902356e10951e622198">More...</a><br/></td></tr>
<tr class="separator:ga3c9ab0fa7ce3b902356e10951e622198"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga93c9313f1a6be27bed9a3becfde0bee7"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga93c9313f1a6be27bed9a3becfde0bee7">core_util_atomic_cas_explicit_u8</a> (volatile uint8_t *ptr, uint8_t *expectedCurrentValue, uint8_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="memdesc:ga93c9313f1a6be27bed9a3becfde0bee7"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#ga93c9313f1a6be27bed9a3becfde0bee7">More...</a><br/></td></tr>
<tr class="separator:ga93c9313f1a6be27bed9a3becfde0bee7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga95a29dd5791c91987be0fed54796f08e"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga95a29dd5791c91987be0fed54796f08e">core_util_atomic_cas_u16</a> (volatile uint16_t *ptr, uint16_t *expectedCurrentValue, uint16_t desiredValue)</td></tr>
<tr class="memdesc:ga95a29dd5791c91987be0fed54796f08e"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#ga95a29dd5791c91987be0fed54796f08e">More...</a><br/></td></tr>
<tr class="separator:ga95a29dd5791c91987be0fed54796f08e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaae923f73dccaad3e5bca9ce02ce47fbe"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaae923f73dccaad3e5bca9ce02ce47fbe">core_util_atomic_cas_explicit_u16</a> (volatile uint16_t *ptr, uint16_t *expectedCurrentValue, uint16_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="memdesc:gaae923f73dccaad3e5bca9ce02ce47fbe"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#gaae923f73dccaad3e5bca9ce02ce47fbe">More...</a><br/></td></tr>
<tr class="separator:gaae923f73dccaad3e5bca9ce02ce47fbe"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga8f1b5edfdabd05b7b2fc400a56e1f9b2"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga8f1b5edfdabd05b7b2fc400a56e1f9b2">core_util_atomic_cas_u32</a> (volatile uint32_t *ptr, uint32_t *expectedCurrentValue, uint32_t desiredValue)</td></tr>
<tr class="memdesc:ga8f1b5edfdabd05b7b2fc400a56e1f9b2"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#ga8f1b5edfdabd05b7b2fc400a56e1f9b2">More...</a><br/></td></tr>
<tr class="separator:ga8f1b5edfdabd05b7b2fc400a56e1f9b2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga87b4b2754592e31420d1f2b38593b8d7"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga87b4b2754592e31420d1f2b38593b8d7">core_util_atomic_cas_explicit_u32</a> (volatile uint32_t *ptr, uint32_t *expectedCurrentValue, uint32_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="memdesc:ga87b4b2754592e31420d1f2b38593b8d7"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#ga87b4b2754592e31420d1f2b38593b8d7">More...</a><br/></td></tr>
<tr class="separator:ga87b4b2754592e31420d1f2b38593b8d7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga85dd9c14f13cf180e6ecdaea8da6fe11"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga85dd9c14f13cf180e6ecdaea8da6fe11">core_util_atomic_cas_u64</a> (volatile uint64_t *ptr, uint64_t *expectedCurrentValue, uint64_t desiredValue)</td></tr>
<tr class="memdesc:ga85dd9c14f13cf180e6ecdaea8da6fe11"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#ga85dd9c14f13cf180e6ecdaea8da6fe11">More...</a><br/></td></tr>
<tr class="separator:ga85dd9c14f13cf180e6ecdaea8da6fe11"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga83dc3029317f487bfef8c984ee92cb06"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga83dc3029317f487bfef8c984ee92cb06">core_util_atomic_cas_explicit_u64</a> (volatile uint64_t *ptr, uint64_t *expectedCurrentValue, uint64_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="memdesc:ga83dc3029317f487bfef8c984ee92cb06"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#ga83dc3029317f487bfef8c984ee92cb06">More...</a><br/></td></tr>
<tr class="separator:ga83dc3029317f487bfef8c984ee92cb06"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga45910fe69f1d67e6f85654e6b137ad3c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga45910fe69f1d67e6f85654e6b137ad3c">core_util_atomic_cas_s8</a> (volatile int8_t *ptr, int8_t *expectedCurrentValue, int8_t desiredValue)</td></tr>
<tr class="memdesc:ga45910fe69f1d67e6f85654e6b137ad3c"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#ga45910fe69f1d67e6f85654e6b137ad3c">More...</a><br/></td></tr>
<tr class="separator:ga45910fe69f1d67e6f85654e6b137ad3c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad741471e0981d7dd88e15b7e285d3eb0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad741471e0981d7dd88e15b7e285d3eb0">core_util_atomic_cas_explicit_s8</a> (volatile int8_t *ptr, int8_t *expectedCurrentValue, int8_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="memdesc:gad741471e0981d7dd88e15b7e285d3eb0"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#gad741471e0981d7dd88e15b7e285d3eb0">More...</a><br/></td></tr>
<tr class="separator:gad741471e0981d7dd88e15b7e285d3eb0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga05d84165af1254189e8c61166ce6b1ff"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga05d84165af1254189e8c61166ce6b1ff">core_util_atomic_cas_s16</a> (volatile int16_t *ptr, int16_t *expectedCurrentValue, int16_t desiredValue)</td></tr>
<tr class="memdesc:ga05d84165af1254189e8c61166ce6b1ff"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#ga05d84165af1254189e8c61166ce6b1ff">More...</a><br/></td></tr>
<tr class="separator:ga05d84165af1254189e8c61166ce6b1ff"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gacf63939b06da44cb49a313698053aeb5"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gacf63939b06da44cb49a313698053aeb5">core_util_atomic_cas_explicit_s16</a> (volatile int16_t *ptr, int16_t *expectedCurrentValue, int16_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="memdesc:gacf63939b06da44cb49a313698053aeb5"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#gacf63939b06da44cb49a313698053aeb5">More...</a><br/></td></tr>
<tr class="separator:gacf63939b06da44cb49a313698053aeb5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga205688ff94fc52b0652c9399d38ed875"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga205688ff94fc52b0652c9399d38ed875">core_util_atomic_cas_s32</a> (volatile int32_t *ptr, int32_t *expectedCurrentValue, int32_t desiredValue)</td></tr>
<tr class="memdesc:ga205688ff94fc52b0652c9399d38ed875"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#ga205688ff94fc52b0652c9399d38ed875">More...</a><br/></td></tr>
<tr class="separator:ga205688ff94fc52b0652c9399d38ed875"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gab572aa9bd7e1ded44f7e6adafb7fe13a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gab572aa9bd7e1ded44f7e6adafb7fe13a">core_util_atomic_cas_explicit_s32</a> (volatile int32_t *ptr, int32_t *expectedCurrentValue, int32_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="memdesc:gab572aa9bd7e1ded44f7e6adafb7fe13a"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#gab572aa9bd7e1ded44f7e6adafb7fe13a">More...</a><br/></td></tr>
<tr class="separator:gab572aa9bd7e1ded44f7e6adafb7fe13a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga6eaa833099480b1cd7f87bb06d93da2d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga6eaa833099480b1cd7f87bb06d93da2d">core_util_atomic_cas_s64</a> (volatile int64_t *ptr, int64_t *expectedCurrentValue, int64_t desiredValue)</td></tr>
<tr class="memdesc:ga6eaa833099480b1cd7f87bb06d93da2d"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#ga6eaa833099480b1cd7f87bb06d93da2d">More...</a><br/></td></tr>
<tr class="separator:ga6eaa833099480b1cd7f87bb06d93da2d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad69a97a89c2881c8a9584602e087729e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad69a97a89c2881c8a9584602e087729e">core_util_atomic_cas_explicit_s64</a> (volatile int64_t *ptr, int64_t *expectedCurrentValue, int64_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="memdesc:gad69a97a89c2881c8a9584602e087729e"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#gad69a97a89c2881c8a9584602e087729e">More...</a><br/></td></tr>
<tr class="separator:gad69a97a89c2881c8a9584602e087729e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gacbf62e56b6923b86006b8f04c57b62e2"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gacbf62e56b6923b86006b8f04c57b62e2">core_util_atomic_cas_bool</a> (volatile bool *ptr, bool *expectedCurrentValue, bool desiredValue)</td></tr>
<tr class="memdesc:gacbf62e56b6923b86006b8f04c57b62e2"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#gacbf62e56b6923b86006b8f04c57b62e2">More...</a><br/></td></tr>
<tr class="separator:gacbf62e56b6923b86006b8f04c57b62e2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga5e8c63fcd66c95d8bf4b29d3bc3745bb"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga5e8c63fcd66c95d8bf4b29d3bc3745bb">core_util_atomic_cas_explicit_bool</a> (volatile bool *ptr, bool *expectedCurrentValue, bool desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="memdesc:ga5e8c63fcd66c95d8bf4b29d3bc3745bb"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#ga5e8c63fcd66c95d8bf4b29d3bc3745bb">More...</a><br/></td></tr>
<tr class="separator:ga5e8c63fcd66c95d8bf4b29d3bc3745bb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaf9e9cbb15b6cae6154a5f85b483e9358"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaf9e9cbb15b6cae6154a5f85b483e9358">core_util_atomic_cas_ptr</a> (void *volatile *ptr, void **expectedCurrentValue, void *desiredValue)</td></tr>
<tr class="memdesc:gaf9e9cbb15b6cae6154a5f85b483e9358"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#gaf9e9cbb15b6cae6154a5f85b483e9358">More...</a><br/></td></tr>
<tr class="separator:gaf9e9cbb15b6cae6154a5f85b483e9358"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga1c3370fd30e8d1721807aad74a7a4f44"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga1c3370fd30e8d1721807aad74a7a4f44">core_util_atomic_cas_explicit_ptr</a> (void *volatile *ptr, void **expectedCurrentValue, void *desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="memdesc:ga1c3370fd30e8d1721807aad74a7a4f44"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#ga1c3370fd30e8d1721807aad74a7a4f44">More...</a><br/></td></tr>
<tr class="separator:ga1c3370fd30e8d1721807aad74a7a4f44"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga80da913bf93f3269a4e35af955f1c660"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga80da913bf93f3269a4e35af955f1c660">core_util_atomic_compare_exchange_weak_u8</a> (volatile uint8_t *ptr, uint8_t *expectedCurrentValue, uint8_t desiredValue)</td></tr>
<tr class="memdesc:ga80da913bf93f3269a4e35af955f1c660"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#ga80da913bf93f3269a4e35af955f1c660">More...</a><br/></td></tr>
<tr class="separator:ga80da913bf93f3269a4e35af955f1c660"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga8ea57a2b4c9d2958d6d4b9d981db3f63"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga8ea57a2b4c9d2958d6d4b9d981db3f63">core_util_atomic_compare_exchange_weak_explicit_u8</a> (volatile uint8_t *ptr, uint8_t *expectedCurrentValue, uint8_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="memdesc:ga8ea57a2b4c9d2958d6d4b9d981db3f63"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#ga8ea57a2b4c9d2958d6d4b9d981db3f63">More...</a><br/></td></tr>
<tr class="separator:ga8ea57a2b4c9d2958d6d4b9d981db3f63"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga5c40ebfb654b853c353ecf67729b3b02"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga5c40ebfb654b853c353ecf67729b3b02">core_util_atomic_compare_exchange_weak_u16</a> (volatile uint16_t *ptr, uint16_t *expectedCurrentValue, uint16_t desiredValue)</td></tr>
<tr class="memdesc:ga5c40ebfb654b853c353ecf67729b3b02"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#ga5c40ebfb654b853c353ecf67729b3b02">More...</a><br/></td></tr>
<tr class="separator:ga5c40ebfb654b853c353ecf67729b3b02"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga5739219816da159aeaae5096ac4f074d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga5739219816da159aeaae5096ac4f074d">core_util_atomic_compare_exchange_weak_explicit_u16</a> (volatile uint16_t *ptr, uint16_t *expectedCurrentValue, uint16_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="memdesc:ga5739219816da159aeaae5096ac4f074d"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#ga5739219816da159aeaae5096ac4f074d">More...</a><br/></td></tr>
<tr class="separator:ga5739219816da159aeaae5096ac4f074d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga140f6e8e10012816365a8812a53cf072"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga140f6e8e10012816365a8812a53cf072">core_util_atomic_compare_exchange_weak_u32</a> (volatile uint32_t *ptr, uint32_t *expectedCurrentValue, uint32_t desiredValue)</td></tr>
<tr class="memdesc:ga140f6e8e10012816365a8812a53cf072"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#ga140f6e8e10012816365a8812a53cf072">More...</a><br/></td></tr>
<tr class="separator:ga140f6e8e10012816365a8812a53cf072"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gafcc40dbc99cecfa5bac04ebd65c9c0a5"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gafcc40dbc99cecfa5bac04ebd65c9c0a5">core_util_atomic_compare_exchange_weak_explicit_u32</a> (volatile uint32_t *ptr, uint32_t *expectedCurrentValue, uint32_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="memdesc:gafcc40dbc99cecfa5bac04ebd65c9c0a5"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#gafcc40dbc99cecfa5bac04ebd65c9c0a5">More...</a><br/></td></tr>
<tr class="separator:gafcc40dbc99cecfa5bac04ebd65c9c0a5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaadaa71b8ed5127cb9591fed2cd524b1e"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaadaa71b8ed5127cb9591fed2cd524b1e">core_util_atomic_compare_exchange_weak_u64</a> (volatile uint64_t *ptr, uint64_t *expectedCurrentValue, uint64_t desiredValue)</td></tr>
<tr class="memdesc:gaadaa71b8ed5127cb9591fed2cd524b1e"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#gaadaa71b8ed5127cb9591fed2cd524b1e">More...</a><br/></td></tr>
<tr class="separator:gaadaa71b8ed5127cb9591fed2cd524b1e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gabb1873cce70f0814a2e65d2bcee84d74"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gabb1873cce70f0814a2e65d2bcee84d74">core_util_atomic_compare_exchange_weak_explicit_u64</a> (volatile uint64_t *ptr, uint64_t *expectedCurrentValue, uint64_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="memdesc:gabb1873cce70f0814a2e65d2bcee84d74"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#gabb1873cce70f0814a2e65d2bcee84d74">More...</a><br/></td></tr>
<tr class="separator:gabb1873cce70f0814a2e65d2bcee84d74"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad18413a098f190ede59e9a7dd817480f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad18413a098f190ede59e9a7dd817480f">core_util_atomic_compare_exchange_weak_s8</a> (volatile int8_t *ptr, int8_t *expectedCurrentValue, int8_t desiredValue)</td></tr>
<tr class="memdesc:gad18413a098f190ede59e9a7dd817480f"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#gad18413a098f190ede59e9a7dd817480f">More...</a><br/></td></tr>
<tr class="separator:gad18413a098f190ede59e9a7dd817480f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga6cdb3fd8dfde2fc0b1da38000982bda5"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga6cdb3fd8dfde2fc0b1da38000982bda5">core_util_atomic_compare_exchange_weak_explicit_s8</a> (volatile int8_t *ptr, int8_t *expectedCurrentValue, int8_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="memdesc:ga6cdb3fd8dfde2fc0b1da38000982bda5"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#ga6cdb3fd8dfde2fc0b1da38000982bda5">More...</a><br/></td></tr>
<tr class="separator:ga6cdb3fd8dfde2fc0b1da38000982bda5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga03b36d178f7b14331ac054ee7de7826e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga03b36d178f7b14331ac054ee7de7826e">core_util_atomic_compare_exchange_weak_s16</a> (volatile int16_t *ptr, int16_t *expectedCurrentValue, int16_t desiredValue)</td></tr>
<tr class="memdesc:ga03b36d178f7b14331ac054ee7de7826e"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#ga03b36d178f7b14331ac054ee7de7826e">More...</a><br/></td></tr>
<tr class="separator:ga03b36d178f7b14331ac054ee7de7826e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga22e345fb761331b2883c063bc6505892"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga22e345fb761331b2883c063bc6505892">core_util_atomic_compare_exchange_weak_explicit_s16</a> (volatile int16_t *ptr, int16_t *expectedCurrentValue, int16_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="memdesc:ga22e345fb761331b2883c063bc6505892"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#ga22e345fb761331b2883c063bc6505892">More...</a><br/></td></tr>
<tr class="separator:ga22e345fb761331b2883c063bc6505892"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaeaf10dda44c9c989072495022edae918"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaeaf10dda44c9c989072495022edae918">core_util_atomic_compare_exchange_weak_s32</a> (volatile int32_t *ptr, int32_t *expectedCurrentValue, int32_t desiredValue)</td></tr>
<tr class="memdesc:gaeaf10dda44c9c989072495022edae918"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#gaeaf10dda44c9c989072495022edae918">More...</a><br/></td></tr>
<tr class="separator:gaeaf10dda44c9c989072495022edae918"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad7686b4293e7ea7bf4950dd5db438c3d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad7686b4293e7ea7bf4950dd5db438c3d">core_util_atomic_compare_exchange_weak_explicit_s32</a> (volatile int32_t *ptr, int32_t *expectedCurrentValue, int32_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="memdesc:gad7686b4293e7ea7bf4950dd5db438c3d"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#gad7686b4293e7ea7bf4950dd5db438c3d">More...</a><br/></td></tr>
<tr class="separator:gad7686b4293e7ea7bf4950dd5db438c3d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga86d26060ebf45bc519c5e769b369977a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga86d26060ebf45bc519c5e769b369977a">core_util_atomic_compare_exchange_weak_s64</a> (volatile int64_t *ptr, int64_t *expectedCurrentValue, int64_t desiredValue)</td></tr>
<tr class="memdesc:ga86d26060ebf45bc519c5e769b369977a"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#ga86d26060ebf45bc519c5e769b369977a">More...</a><br/></td></tr>
<tr class="separator:ga86d26060ebf45bc519c5e769b369977a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gae818c803e9b789a9155f2582957284cc"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gae818c803e9b789a9155f2582957284cc">core_util_atomic_compare_exchange_weak_explicit_s64</a> (volatile int64_t *ptr, int64_t *expectedCurrentValue, int64_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="memdesc:gae818c803e9b789a9155f2582957284cc"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#gae818c803e9b789a9155f2582957284cc">More...</a><br/></td></tr>
<tr class="separator:gae818c803e9b789a9155f2582957284cc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gab1d769b78dbd7f22cbb904d7b768ca45"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gab1d769b78dbd7f22cbb904d7b768ca45">core_util_atomic_compare_exchange_weak_bool</a> (volatile bool *ptr, bool *expectedCurrentValue, bool desiredValue)</td></tr>
<tr class="memdesc:gab1d769b78dbd7f22cbb904d7b768ca45"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#gab1d769b78dbd7f22cbb904d7b768ca45">More...</a><br/></td></tr>
<tr class="separator:gab1d769b78dbd7f22cbb904d7b768ca45"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gadeec7abf1f4deb39287ae36d53e543b4"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gadeec7abf1f4deb39287ae36d53e543b4">core_util_atomic_compare_exchange_weak_explicit_bool</a> (volatile bool *ptr, bool *expectedCurrentValue, bool desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="memdesc:gadeec7abf1f4deb39287ae36d53e543b4"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#gadeec7abf1f4deb39287ae36d53e543b4">More...</a><br/></td></tr>
<tr class="separator:gadeec7abf1f4deb39287ae36d53e543b4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaf1778c0381b19ace75e5228c4be8448d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaf1778c0381b19ace75e5228c4be8448d">core_util_atomic_compare_exchange_weak_ptr</a> (void *volatile *ptr, void **expectedCurrentValue, void *desiredValue)</td></tr>
<tr class="memdesc:gaf1778c0381b19ace75e5228c4be8448d"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#gaf1778c0381b19ace75e5228c4be8448d">More...</a><br/></td></tr>
<tr class="separator:gaf1778c0381b19ace75e5228c4be8448d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga0ad9cc64f6c880a1608a120f41c8ffbb"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga0ad9cc64f6c880a1608a120f41c8ffbb">core_util_atomic_compare_exchange_weak_explicit_ptr</a> (void *volatile *ptr, void **expectedCurrentValue, void *desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="memdesc:ga0ad9cc64f6c880a1608a120f41c8ffbb"><td class="mdescLeft"> </td><td class="mdescRight">Atomic compare and set.  <a href="#ga0ad9cc64f6c880a1608a120f41c8ffbb">More...</a><br/></td></tr>
<tr class="separator:ga0ad9cc64f6c880a1608a120f41c8ffbb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga2840954e59468ea85b91e17ca50ad009"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga2840954e59468ea85b91e17ca50ad009">core_util_atomic_load_u8</a> (const volatile uint8_t *valuePtr)</td></tr>
<tr class="memdesc:ga2840954e59468ea85b91e17ca50ad009"><td class="mdescLeft"> </td><td class="mdescRight">Atomic load.  <a href="#ga2840954e59468ea85b91e17ca50ad009">More...</a><br/></td></tr>
<tr class="separator:ga2840954e59468ea85b91e17ca50ad009"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga4b5b21126d2a22858faaf8018b5e66f9"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga4b5b21126d2a22858faaf8018b5e66f9">core_util_atomic_load_explicit_u8</a> (const volatile uint8_t *valuePtr, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga4b5b21126d2a22858faaf8018b5e66f9"><td class="mdescLeft"> </td><td class="mdescRight">Atomic load.  <a href="#ga4b5b21126d2a22858faaf8018b5e66f9">More...</a><br/></td></tr>
<tr class="separator:ga4b5b21126d2a22858faaf8018b5e66f9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga6b13b1196ed2a63802d7acf2ea08aaf4"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga6b13b1196ed2a63802d7acf2ea08aaf4">core_util_atomic_load_u16</a> (const volatile uint16_t *valuePtr)</td></tr>
<tr class="memdesc:ga6b13b1196ed2a63802d7acf2ea08aaf4"><td class="mdescLeft"> </td><td class="mdescRight">Atomic load.  <a href="#ga6b13b1196ed2a63802d7acf2ea08aaf4">More...</a><br/></td></tr>
<tr class="separator:ga6b13b1196ed2a63802d7acf2ea08aaf4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga2a81771e47a93b508d6ec3f4666b506e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga2a81771e47a93b508d6ec3f4666b506e">core_util_atomic_load_explicit_u16</a> (const volatile uint16_t *valuePtr, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga2a81771e47a93b508d6ec3f4666b506e"><td class="mdescLeft"> </td><td class="mdescRight">Atomic load.  <a href="#ga2a81771e47a93b508d6ec3f4666b506e">More...</a><br/></td></tr>
<tr class="separator:ga2a81771e47a93b508d6ec3f4666b506e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gade580faac99dbf59aeda5da1e4c213ad"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gade580faac99dbf59aeda5da1e4c213ad">core_util_atomic_load_u32</a> (const volatile uint32_t *valuePtr)</td></tr>
<tr class="memdesc:gade580faac99dbf59aeda5da1e4c213ad"><td class="mdescLeft"> </td><td class="mdescRight">Atomic load.  <a href="#gade580faac99dbf59aeda5da1e4c213ad">More...</a><br/></td></tr>
<tr class="separator:gade580faac99dbf59aeda5da1e4c213ad"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaa85935b1f85886bd69c028aad61d16ce"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaa85935b1f85886bd69c028aad61d16ce">core_util_atomic_load_explicit_u32</a> (const volatile uint32_t *valuePtr, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gaa85935b1f85886bd69c028aad61d16ce"><td class="mdescLeft"> </td><td class="mdescRight">Atomic load.  <a href="#gaa85935b1f85886bd69c028aad61d16ce">More...</a><br/></td></tr>
<tr class="separator:gaa85935b1f85886bd69c028aad61d16ce"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gae79f750b7b18b9b6c54b9f67c235195f"><td align="right" class="memItemLeft" valign="top">uint64_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gae79f750b7b18b9b6c54b9f67c235195f">core_util_atomic_load_u64</a> (const volatile uint64_t *valuePtr)</td></tr>
<tr class="memdesc:gae79f750b7b18b9b6c54b9f67c235195f"><td class="mdescLeft"> </td><td class="mdescRight">Atomic load.  <a href="#gae79f750b7b18b9b6c54b9f67c235195f">More...</a><br/></td></tr>
<tr class="separator:gae79f750b7b18b9b6c54b9f67c235195f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaf24e043d3f39b59e5c4e53f7d39558d0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaf24e043d3f39b59e5c4e53f7d39558d0">core_util_atomic_load_explicit_u64</a> (const volatile uint64_t *valuePtr, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gaf24e043d3f39b59e5c4e53f7d39558d0"><td class="mdescLeft"> </td><td class="mdescRight">Atomic load.  <a href="#gaf24e043d3f39b59e5c4e53f7d39558d0">More...</a><br/></td></tr>
<tr class="separator:gaf24e043d3f39b59e5c4e53f7d39558d0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaeecfddc99e71a90287f0220e8fd3e206"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaeecfddc99e71a90287f0220e8fd3e206">core_util_atomic_load_s8</a> (const volatile int8_t *valuePtr)</td></tr>
<tr class="memdesc:gaeecfddc99e71a90287f0220e8fd3e206"><td class="mdescLeft"> </td><td class="mdescRight">Atomic load.  <a href="#gaeecfddc99e71a90287f0220e8fd3e206">More...</a><br/></td></tr>
<tr class="separator:gaeecfddc99e71a90287f0220e8fd3e206"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga765734c8f47168fbf2e1d3583466df96"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga765734c8f47168fbf2e1d3583466df96">core_util_atomic_load_explicit_s8</a> (const volatile int8_t *valuePtr, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga765734c8f47168fbf2e1d3583466df96"><td class="mdescLeft"> </td><td class="mdescRight">Atomic load.  <a href="#ga765734c8f47168fbf2e1d3583466df96">More...</a><br/></td></tr>
<tr class="separator:ga765734c8f47168fbf2e1d3583466df96"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga663356b18705a1c4ae4d87643ae239f6"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga663356b18705a1c4ae4d87643ae239f6">core_util_atomic_load_s16</a> (const volatile int16_t *valuePtr)</td></tr>
<tr class="memdesc:ga663356b18705a1c4ae4d87643ae239f6"><td class="mdescLeft"> </td><td class="mdescRight">Atomic load.  <a href="#ga663356b18705a1c4ae4d87643ae239f6">More...</a><br/></td></tr>
<tr class="separator:ga663356b18705a1c4ae4d87643ae239f6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga99004d90211c9e8b31d40a5a86312a8f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga99004d90211c9e8b31d40a5a86312a8f">core_util_atomic_load_explicit_s16</a> (const volatile int16_t *valuePtr, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga99004d90211c9e8b31d40a5a86312a8f"><td class="mdescLeft"> </td><td class="mdescRight">Atomic load.  <a href="#ga99004d90211c9e8b31d40a5a86312a8f">More...</a><br/></td></tr>
<tr class="separator:ga99004d90211c9e8b31d40a5a86312a8f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga1994aaeae2efb36b58051da401a95b36"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga1994aaeae2efb36b58051da401a95b36">core_util_atomic_load_s32</a> (const volatile int32_t *valuePtr)</td></tr>
<tr class="memdesc:ga1994aaeae2efb36b58051da401a95b36"><td class="mdescLeft"> </td><td class="mdescRight">Atomic load.  <a href="#ga1994aaeae2efb36b58051da401a95b36">More...</a><br/></td></tr>
<tr class="separator:ga1994aaeae2efb36b58051da401a95b36"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga5a70e0153206702a003de75ffe9b86aa"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga5a70e0153206702a003de75ffe9b86aa">core_util_atomic_load_explicit_s32</a> (const volatile int32_t *valuePtr, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga5a70e0153206702a003de75ffe9b86aa"><td class="mdescLeft"> </td><td class="mdescRight">Atomic load.  <a href="#ga5a70e0153206702a003de75ffe9b86aa">More...</a><br/></td></tr>
<tr class="separator:ga5a70e0153206702a003de75ffe9b86aa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga100297ebd80cd21846398c6ad7d81f43"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga100297ebd80cd21846398c6ad7d81f43">core_util_atomic_load_s64</a> (const volatile int64_t *valuePtr)</td></tr>
<tr class="memdesc:ga100297ebd80cd21846398c6ad7d81f43"><td class="mdescLeft"> </td><td class="mdescRight">Atomic load.  <a href="#ga100297ebd80cd21846398c6ad7d81f43">More...</a><br/></td></tr>
<tr class="separator:ga100297ebd80cd21846398c6ad7d81f43"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga426c13fee706b73968b19273be5544fd"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga426c13fee706b73968b19273be5544fd">core_util_atomic_load_explicit_s64</a> (const volatile int64_t *valuePtr, <a class="el" href="group__platform__toolchain.html#ga3e0b3dc191a8e64de80be44bbc8d5193">MBED_UNUSED</a> <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga426c13fee706b73968b19273be5544fd"><td class="mdescLeft"> </td><td class="mdescRight">Atomic load.  <a href="#ga426c13fee706b73968b19273be5544fd">More...</a><br/></td></tr>
<tr class="separator:ga426c13fee706b73968b19273be5544fd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaba968e929680be76321b4c639287f968"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaba968e929680be76321b4c639287f968">core_util_atomic_load_bool</a> (const volatile bool *valuePtr)</td></tr>
<tr class="memdesc:gaba968e929680be76321b4c639287f968"><td class="mdescLeft"> </td><td class="mdescRight">Atomic load.  <a href="#gaba968e929680be76321b4c639287f968">More...</a><br/></td></tr>
<tr class="separator:gaba968e929680be76321b4c639287f968"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga2b4b4c68346a582ed810f5a42f9083e6"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga2b4b4c68346a582ed810f5a42f9083e6">core_util_atomic_load_explicit_bool</a> (const volatile bool *valuePtr, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga2b4b4c68346a582ed810f5a42f9083e6"><td class="mdescLeft"> </td><td class="mdescRight">Atomic load.  <a href="#ga2b4b4c68346a582ed810f5a42f9083e6">More...</a><br/></td></tr>
<tr class="separator:ga2b4b4c68346a582ed810f5a42f9083e6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga424a1a464d29f0afcf7fde90c337803a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void * </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga424a1a464d29f0afcf7fde90c337803a">core_util_atomic_load_ptr</a> (void *const volatile *valuePtr)</td></tr>
<tr class="memdesc:ga424a1a464d29f0afcf7fde90c337803a"><td class="mdescLeft"> </td><td class="mdescRight">Atomic load.  <a href="#ga424a1a464d29f0afcf7fde90c337803a">More...</a><br/></td></tr>
<tr class="separator:ga424a1a464d29f0afcf7fde90c337803a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga8b245bc78b514cf7c773aee565b2039e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void * </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga8b245bc78b514cf7c773aee565b2039e">core_util_atomic_load_explicit_ptr</a> (void *const volatile *valuePtr, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga8b245bc78b514cf7c773aee565b2039e"><td class="mdescLeft"> </td><td class="mdescRight">Atomic load.  <a href="#ga8b245bc78b514cf7c773aee565b2039e">More...</a><br/></td></tr>
<tr class="separator:ga8b245bc78b514cf7c773aee565b2039e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaf5c3fa6d415e012c34c7c82056817f29"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaf5c3fa6d415e012c34c7c82056817f29">core_util_atomic_store_u8</a> (volatile uint8_t *valuePtr, uint8_t desiredValue)</td></tr>
<tr class="memdesc:gaf5c3fa6d415e012c34c7c82056817f29"><td class="mdescLeft"> </td><td class="mdescRight">Atomic store.  <a href="#gaf5c3fa6d415e012c34c7c82056817f29">More...</a><br/></td></tr>
<tr class="separator:gaf5c3fa6d415e012c34c7c82056817f29"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaca1cdaf85b894b8bccb88e870577f324"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaca1cdaf85b894b8bccb88e870577f324">core_util_atomic_store_explicit_u8</a> (volatile uint8_t *valuePtr, uint8_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gaca1cdaf85b894b8bccb88e870577f324"><td class="mdescLeft"> </td><td class="mdescRight">Atomic store.  <a href="#gaca1cdaf85b894b8bccb88e870577f324">More...</a><br/></td></tr>
<tr class="separator:gaca1cdaf85b894b8bccb88e870577f324"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga2f38862b163d1a943b28dabfd39fc8ef"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga2f38862b163d1a943b28dabfd39fc8ef">core_util_atomic_store_u16</a> (volatile uint16_t *valuePtr, uint16_t desiredValue)</td></tr>
<tr class="memdesc:ga2f38862b163d1a943b28dabfd39fc8ef"><td class="mdescLeft"> </td><td class="mdescRight">Atomic store.  <a href="#ga2f38862b163d1a943b28dabfd39fc8ef">More...</a><br/></td></tr>
<tr class="separator:ga2f38862b163d1a943b28dabfd39fc8ef"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad81d69ed6094e7cd6cfb1f3b729955fc"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad81d69ed6094e7cd6cfb1f3b729955fc">core_util_atomic_store_explicit_u16</a> (volatile uint16_t *valuePtr, uint16_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gad81d69ed6094e7cd6cfb1f3b729955fc"><td class="mdescLeft"> </td><td class="mdescRight">Atomic store.  <a href="#gad81d69ed6094e7cd6cfb1f3b729955fc">More...</a><br/></td></tr>
<tr class="separator:gad81d69ed6094e7cd6cfb1f3b729955fc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga981dd31a80f495369723280424a3999e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga981dd31a80f495369723280424a3999e">core_util_atomic_store_u32</a> (volatile uint32_t *valuePtr, uint32_t desiredValue)</td></tr>
<tr class="memdesc:ga981dd31a80f495369723280424a3999e"><td class="mdescLeft"> </td><td class="mdescRight">Atomic store.  <a href="#ga981dd31a80f495369723280424a3999e">More...</a><br/></td></tr>
<tr class="separator:ga981dd31a80f495369723280424a3999e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga2960e2d63e4c37c93f202cbb597189a9"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga2960e2d63e4c37c93f202cbb597189a9">core_util_atomic_store_explicit_u32</a> (volatile uint32_t *valuePtr, uint32_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga2960e2d63e4c37c93f202cbb597189a9"><td class="mdescLeft"> </td><td class="mdescRight">Atomic store.  <a href="#ga2960e2d63e4c37c93f202cbb597189a9">More...</a><br/></td></tr>
<tr class="separator:ga2960e2d63e4c37c93f202cbb597189a9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaaffb39f69f9e80d787404bcdc627bd39"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaaffb39f69f9e80d787404bcdc627bd39">core_util_atomic_store_u64</a> (volatile uint64_t *valuePtr, uint64_t desiredValue)</td></tr>
<tr class="memdesc:gaaffb39f69f9e80d787404bcdc627bd39"><td class="mdescLeft"> </td><td class="mdescRight">Atomic store.  <a href="#gaaffb39f69f9e80d787404bcdc627bd39">More...</a><br/></td></tr>
<tr class="separator:gaaffb39f69f9e80d787404bcdc627bd39"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad54a248229f8606e148c9708c7237334"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad54a248229f8606e148c9708c7237334">core_util_atomic_store_explicit_u64</a> (volatile uint64_t *valuePtr, uint64_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gad54a248229f8606e148c9708c7237334"><td class="mdescLeft"> </td><td class="mdescRight">Atomic store.  <a href="#gad54a248229f8606e148c9708c7237334">More...</a><br/></td></tr>
<tr class="separator:gad54a248229f8606e148c9708c7237334"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga2024d6b1bd77f35d0bd27b9abeaca252"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga2024d6b1bd77f35d0bd27b9abeaca252">core_util_atomic_store_s8</a> (volatile int8_t *valuePtr, int8_t desiredValue)</td></tr>
<tr class="memdesc:ga2024d6b1bd77f35d0bd27b9abeaca252"><td class="mdescLeft"> </td><td class="mdescRight">Atomic store.  <a href="#ga2024d6b1bd77f35d0bd27b9abeaca252">More...</a><br/></td></tr>
<tr class="separator:ga2024d6b1bd77f35d0bd27b9abeaca252"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga361bc02b02df102a3f3ddf0ae84a9df0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga361bc02b02df102a3f3ddf0ae84a9df0">core_util_atomic_store_explicit_s8</a> (volatile int8_t *valuePtr, int8_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga361bc02b02df102a3f3ddf0ae84a9df0"><td class="mdescLeft"> </td><td class="mdescRight">Atomic store.  <a href="#ga361bc02b02df102a3f3ddf0ae84a9df0">More...</a><br/></td></tr>
<tr class="separator:ga361bc02b02df102a3f3ddf0ae84a9df0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gae67ef75f813610e1bd3804b4cfa22565"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gae67ef75f813610e1bd3804b4cfa22565">core_util_atomic_store_s16</a> (volatile int16_t *valuePtr, int16_t desiredValue)</td></tr>
<tr class="memdesc:gae67ef75f813610e1bd3804b4cfa22565"><td class="mdescLeft"> </td><td class="mdescRight">Atomic store.  <a href="#gae67ef75f813610e1bd3804b4cfa22565">More...</a><br/></td></tr>
<tr class="separator:gae67ef75f813610e1bd3804b4cfa22565"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaedd333e4cab3877d64f041e538cff66b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaedd333e4cab3877d64f041e538cff66b">core_util_atomic_store_explicit_s16</a> (volatile int16_t *valuePtr, int16_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gaedd333e4cab3877d64f041e538cff66b"><td class="mdescLeft"> </td><td class="mdescRight">Atomic store.  <a href="#gaedd333e4cab3877d64f041e538cff66b">More...</a><br/></td></tr>
<tr class="separator:gaedd333e4cab3877d64f041e538cff66b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga63d826b01dc7aae7c3a473c349f0ee32"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga63d826b01dc7aae7c3a473c349f0ee32">core_util_atomic_store_s32</a> (volatile int32_t *valuePtr, int32_t desiredValue)</td></tr>
<tr class="memdesc:ga63d826b01dc7aae7c3a473c349f0ee32"><td class="mdescLeft"> </td><td class="mdescRight">Atomic store.  <a href="#ga63d826b01dc7aae7c3a473c349f0ee32">More...</a><br/></td></tr>
<tr class="separator:ga63d826b01dc7aae7c3a473c349f0ee32"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga3b27494dba292ef9caa12d164b7a1b9d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga3b27494dba292ef9caa12d164b7a1b9d">core_util_atomic_store_explicit_s32</a> (volatile int32_t *valuePtr, int32_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga3b27494dba292ef9caa12d164b7a1b9d"><td class="mdescLeft"> </td><td class="mdescRight">Atomic store.  <a href="#ga3b27494dba292ef9caa12d164b7a1b9d">More...</a><br/></td></tr>
<tr class="separator:ga3b27494dba292ef9caa12d164b7a1b9d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga15431b3da92b29949c1d597f425c7a07"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga15431b3da92b29949c1d597f425c7a07">core_util_atomic_store_s64</a> (volatile int64_t *valuePtr, int64_t desiredValue)</td></tr>
<tr class="memdesc:ga15431b3da92b29949c1d597f425c7a07"><td class="mdescLeft"> </td><td class="mdescRight">Atomic store.  <a href="#ga15431b3da92b29949c1d597f425c7a07">More...</a><br/></td></tr>
<tr class="separator:ga15431b3da92b29949c1d597f425c7a07"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gade28bd9fce9c1c0f448eab73cb00e460"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gade28bd9fce9c1c0f448eab73cb00e460">core_util_atomic_store_explicit_s64</a> (volatile int64_t *valuePtr, int64_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gade28bd9fce9c1c0f448eab73cb00e460"><td class="mdescLeft"> </td><td class="mdescRight">Atomic store.  <a href="#gade28bd9fce9c1c0f448eab73cb00e460">More...</a><br/></td></tr>
<tr class="separator:gade28bd9fce9c1c0f448eab73cb00e460"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga4692889cc8d1bd170af962728be04dc3"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga4692889cc8d1bd170af962728be04dc3">core_util_atomic_store_bool</a> (volatile bool *valuePtr, bool desiredValue)</td></tr>
<tr class="memdesc:ga4692889cc8d1bd170af962728be04dc3"><td class="mdescLeft"> </td><td class="mdescRight">Atomic store.  <a href="#ga4692889cc8d1bd170af962728be04dc3">More...</a><br/></td></tr>
<tr class="separator:ga4692889cc8d1bd170af962728be04dc3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gab9ca948b9322559e941dd359400ae4fe"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gab9ca948b9322559e941dd359400ae4fe">core_util_atomic_store_explicit_bool</a> (volatile bool *valuePtr, bool desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gab9ca948b9322559e941dd359400ae4fe"><td class="mdescLeft"> </td><td class="mdescRight">Atomic store.  <a href="#gab9ca948b9322559e941dd359400ae4fe">More...</a><br/></td></tr>
<tr class="separator:gab9ca948b9322559e941dd359400ae4fe"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaa112a4db89b94efa5f785035415f0d5a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaa112a4db89b94efa5f785035415f0d5a">core_util_atomic_store_ptr</a> (void *volatile *valuePtr, void *desiredValue)</td></tr>
<tr class="memdesc:gaa112a4db89b94efa5f785035415f0d5a"><td class="mdescLeft"> </td><td class="mdescRight">Atomic store.  <a href="#gaa112a4db89b94efa5f785035415f0d5a">More...</a><br/></td></tr>
<tr class="separator:gaa112a4db89b94efa5f785035415f0d5a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaca4ebe09fe2de1ddc6ce8151baefc991"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaca4ebe09fe2de1ddc6ce8151baefc991">core_util_atomic_store_explicit_ptr</a> (void *volatile *valuePtr, void *desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gaca4ebe09fe2de1ddc6ce8151baefc991"><td class="mdescLeft"> </td><td class="mdescRight">Atomic store.  <a href="#gaca4ebe09fe2de1ddc6ce8151baefc991">More...</a><br/></td></tr>
<tr class="separator:gaca4ebe09fe2de1ddc6ce8151baefc991"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga59e7a27bc6ea2f39a9ebaad40859bfe5"><td align="right" class="memItemLeft" valign="top">uint8_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga59e7a27bc6ea2f39a9ebaad40859bfe5">core_util_atomic_exchange_u8</a> (volatile uint8_t *valuePtr, uint8_t desiredValue)</td></tr>
<tr class="memdesc:ga59e7a27bc6ea2f39a9ebaad40859bfe5"><td class="mdescLeft"> </td><td class="mdescRight">Atomic exchange.  <a href="#ga59e7a27bc6ea2f39a9ebaad40859bfe5">More...</a><br/></td></tr>
<tr class="separator:ga59e7a27bc6ea2f39a9ebaad40859bfe5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gac7780847ac95064b466ea04bad2a61a2"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gac7780847ac95064b466ea04bad2a61a2">core_util_atomic_exchange_explicit_u8</a> (volatile uint8_t *valuePtr, uint8_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gac7780847ac95064b466ea04bad2a61a2"><td class="mdescLeft"> </td><td class="mdescRight">Atomic exchange.  <a href="#gac7780847ac95064b466ea04bad2a61a2">More...</a><br/></td></tr>
<tr class="separator:gac7780847ac95064b466ea04bad2a61a2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gae8bff86f0c961096d11b9e4f1b7069ae"><td align="right" class="memItemLeft" valign="top">uint16_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gae8bff86f0c961096d11b9e4f1b7069ae">core_util_atomic_exchange_u16</a> (volatile uint16_t *valuePtr, uint16_t desiredValue)</td></tr>
<tr class="memdesc:gae8bff86f0c961096d11b9e4f1b7069ae"><td class="mdescLeft"> </td><td class="mdescRight">Atomic exchange.  <a href="#gae8bff86f0c961096d11b9e4f1b7069ae">More...</a><br/></td></tr>
<tr class="separator:gae8bff86f0c961096d11b9e4f1b7069ae"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga09407fb1c3ba1c8518e09b75bc12c6e0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga09407fb1c3ba1c8518e09b75bc12c6e0">core_util_atomic_exchange_explicit_u16</a> (volatile uint16_t *valuePtr, uint16_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga09407fb1c3ba1c8518e09b75bc12c6e0"><td class="mdescLeft"> </td><td class="mdescRight">Atomic exchange.  <a href="#ga09407fb1c3ba1c8518e09b75bc12c6e0">More...</a><br/></td></tr>
<tr class="separator:ga09407fb1c3ba1c8518e09b75bc12c6e0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga22e6020a2efeda8cce823c38b8d223d0"><td align="right" class="memItemLeft" valign="top">uint32_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga22e6020a2efeda8cce823c38b8d223d0">core_util_atomic_exchange_u32</a> (volatile uint32_t *valuePtr, uint32_t desiredValue)</td></tr>
<tr class="memdesc:ga22e6020a2efeda8cce823c38b8d223d0"><td class="mdescLeft"> </td><td class="mdescRight">Atomic exchange.  <a href="#ga22e6020a2efeda8cce823c38b8d223d0">More...</a><br/></td></tr>
<tr class="separator:ga22e6020a2efeda8cce823c38b8d223d0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga3cd0876d934c04cf3d097d6048d5b94c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga3cd0876d934c04cf3d097d6048d5b94c">core_util_atomic_exchange_explicit_u32</a> (volatile uint32_t *valuePtr, uint32_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga3cd0876d934c04cf3d097d6048d5b94c"><td class="mdescLeft"> </td><td class="mdescRight">Atomic exchange.  <a href="#ga3cd0876d934c04cf3d097d6048d5b94c">More...</a><br/></td></tr>
<tr class="separator:ga3cd0876d934c04cf3d097d6048d5b94c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga7a53ffc716df9594b56a94fca8ce5cf7"><td align="right" class="memItemLeft" valign="top">uint64_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga7a53ffc716df9594b56a94fca8ce5cf7">core_util_atomic_exchange_u64</a> (volatile uint64_t *valuePtr, uint64_t desiredValue)</td></tr>
<tr class="memdesc:ga7a53ffc716df9594b56a94fca8ce5cf7"><td class="mdescLeft"> </td><td class="mdescRight">Atomic exchange.  <a href="#ga7a53ffc716df9594b56a94fca8ce5cf7">More...</a><br/></td></tr>
<tr class="separator:ga7a53ffc716df9594b56a94fca8ce5cf7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gab492757a2fc1fdaed58f56877126fc85"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gab492757a2fc1fdaed58f56877126fc85">core_util_atomic_exchange_explicit_u64</a> (volatile uint64_t *valuePtr, uint64_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gab492757a2fc1fdaed58f56877126fc85"><td class="mdescLeft"> </td><td class="mdescRight">Atomic exchange.  <a href="#gab492757a2fc1fdaed58f56877126fc85">More...</a><br/></td></tr>
<tr class="separator:gab492757a2fc1fdaed58f56877126fc85"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga9c915efbc7c77b3c72328783af87277d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga9c915efbc7c77b3c72328783af87277d">core_util_atomic_exchange_s8</a> (volatile int8_t *valuePtr, int8_t desiredValue)</td></tr>
<tr class="memdesc:ga9c915efbc7c77b3c72328783af87277d"><td class="mdescLeft"> </td><td class="mdescRight">Atomic exchange.  <a href="#ga9c915efbc7c77b3c72328783af87277d">More...</a><br/></td></tr>
<tr class="separator:ga9c915efbc7c77b3c72328783af87277d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gab32133579ae8ddda64548e209f85a282"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gab32133579ae8ddda64548e209f85a282">core_util_atomic_exchange_explicit_s8</a> (volatile int8_t *valuePtr, int8_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gab32133579ae8ddda64548e209f85a282"><td class="mdescLeft"> </td><td class="mdescRight">Atomic exchange.  <a href="#gab32133579ae8ddda64548e209f85a282">More...</a><br/></td></tr>
<tr class="separator:gab32133579ae8ddda64548e209f85a282"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad02cc6c6d66a90be4b943dd02a682089"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad02cc6c6d66a90be4b943dd02a682089">core_util_atomic_exchange_s16</a> (volatile int16_t *valuePtr, int16_t desiredValue)</td></tr>
<tr class="memdesc:gad02cc6c6d66a90be4b943dd02a682089"><td class="mdescLeft"> </td><td class="mdescRight">Atomic exchange.  <a href="#gad02cc6c6d66a90be4b943dd02a682089">More...</a><br/></td></tr>
<tr class="separator:gad02cc6c6d66a90be4b943dd02a682089"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga3ff86a2b74166999e50784676e624a9c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga3ff86a2b74166999e50784676e624a9c">core_util_atomic_exchange_explicit_s16</a> (volatile int16_t *valuePtr, int16_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga3ff86a2b74166999e50784676e624a9c"><td class="mdescLeft"> </td><td class="mdescRight">Atomic exchange.  <a href="#ga3ff86a2b74166999e50784676e624a9c">More...</a><br/></td></tr>
<tr class="separator:ga3ff86a2b74166999e50784676e624a9c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaa5592ae0738feab92516d27d14c0921b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaa5592ae0738feab92516d27d14c0921b">core_util_atomic_exchange_s32</a> (volatile int32_t *valuePtr, int32_t desiredValue)</td></tr>
<tr class="memdesc:gaa5592ae0738feab92516d27d14c0921b"><td class="mdescLeft"> </td><td class="mdescRight">Atomic exchange.  <a href="#gaa5592ae0738feab92516d27d14c0921b">More...</a><br/></td></tr>
<tr class="separator:gaa5592ae0738feab92516d27d14c0921b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaf601f85ee6eff49b498bd02d5355b986"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaf601f85ee6eff49b498bd02d5355b986">core_util_atomic_exchange_explicit_s32</a> (volatile int32_t *valuePtr, int32_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gaf601f85ee6eff49b498bd02d5355b986"><td class="mdescLeft"> </td><td class="mdescRight">Atomic exchange.  <a href="#gaf601f85ee6eff49b498bd02d5355b986">More...</a><br/></td></tr>
<tr class="separator:gaf601f85ee6eff49b498bd02d5355b986"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gac09a70a91d5b50e5e4d18af85f8224de"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gac09a70a91d5b50e5e4d18af85f8224de">core_util_atomic_exchange_s64</a> (volatile int64_t *valuePtr, int64_t desiredValue)</td></tr>
<tr class="memdesc:gac09a70a91d5b50e5e4d18af85f8224de"><td class="mdescLeft"> </td><td class="mdescRight">Atomic exchange.  <a href="#gac09a70a91d5b50e5e4d18af85f8224de">More...</a><br/></td></tr>
<tr class="separator:gac09a70a91d5b50e5e4d18af85f8224de"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga44a1020edbe4b1cfc98cb2470b228c07"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga44a1020edbe4b1cfc98cb2470b228c07">core_util_atomic_exchange_explicit_s64</a> (volatile int64_t *valuePtr, int64_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga44a1020edbe4b1cfc98cb2470b228c07"><td class="mdescLeft"> </td><td class="mdescRight">Atomic exchange.  <a href="#ga44a1020edbe4b1cfc98cb2470b228c07">More...</a><br/></td></tr>
<tr class="separator:ga44a1020edbe4b1cfc98cb2470b228c07"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga085fd843aab08f03815e6925b7b56e35"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga085fd843aab08f03815e6925b7b56e35">core_util_atomic_exchange_bool</a> (volatile bool *valuePtr, bool desiredValue)</td></tr>
<tr class="memdesc:ga085fd843aab08f03815e6925b7b56e35"><td class="mdescLeft"> </td><td class="mdescRight">Atomic exchange.  <a href="#ga085fd843aab08f03815e6925b7b56e35">More...</a><br/></td></tr>
<tr class="separator:ga085fd843aab08f03815e6925b7b56e35"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga11616204b0007487d3607cfd0036e966"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga11616204b0007487d3607cfd0036e966">core_util_atomic_exchange_explicit_bool</a> (volatile bool *valuePtr, bool desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga11616204b0007487d3607cfd0036e966"><td class="mdescLeft"> </td><td class="mdescRight">Atomic exchange.  <a href="#ga11616204b0007487d3607cfd0036e966">More...</a><br/></td></tr>
<tr class="separator:ga11616204b0007487d3607cfd0036e966"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga450de337870f36a050d21a4b339b3c67"><td align="right" class="memItemLeft" valign="top">void * </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga450de337870f36a050d21a4b339b3c67">core_util_atomic_exchange_ptr</a> (void *volatile *valuePtr, void *desiredValue)</td></tr>
<tr class="memdesc:ga450de337870f36a050d21a4b339b3c67"><td class="mdescLeft"> </td><td class="mdescRight">Atomic exchange.  <a href="#ga450de337870f36a050d21a4b339b3c67">More...</a><br/></td></tr>
<tr class="separator:ga450de337870f36a050d21a4b339b3c67"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gac2352249f1c125048113668dd898c865"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void * </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gac2352249f1c125048113668dd898c865">core_util_atomic_exchange_explicit_ptr</a> (void *volatile *valuePtr, void *desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gac2352249f1c125048113668dd898c865"><td class="mdescLeft"> </td><td class="mdescRight">Atomic exchange.  <a href="#gac2352249f1c125048113668dd898c865">More...</a><br/></td></tr>
<tr class="separator:gac2352249f1c125048113668dd898c865"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga7b2738cdb036dd4bf42c8a496107b3c9"><td align="right" class="memItemLeft" valign="top">uint8_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga7b2738cdb036dd4bf42c8a496107b3c9">core_util_atomic_incr_u8</a> (volatile uint8_t *valuePtr, uint8_t delta)</td></tr>
<tr class="memdesc:ga7b2738cdb036dd4bf42c8a496107b3c9"><td class="mdescLeft"> </td><td class="mdescRight">Atomic increment.  <a href="#ga7b2738cdb036dd4bf42c8a496107b3c9">More...</a><br/></td></tr>
<tr class="separator:ga7b2738cdb036dd4bf42c8a496107b3c9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaf11cb4e3404afe3549a26c852934c8df"><td align="right" class="memItemLeft" valign="top">uint16_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaf11cb4e3404afe3549a26c852934c8df">core_util_atomic_incr_u16</a> (volatile uint16_t *valuePtr, uint16_t delta)</td></tr>
<tr class="memdesc:gaf11cb4e3404afe3549a26c852934c8df"><td class="mdescLeft"> </td><td class="mdescRight">Atomic increment.  <a href="#gaf11cb4e3404afe3549a26c852934c8df">More...</a><br/></td></tr>
<tr class="separator:gaf11cb4e3404afe3549a26c852934c8df"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga4a9fd9661ae1db338cd776ba45f3ad33"><td align="right" class="memItemLeft" valign="top">uint32_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga4a9fd9661ae1db338cd776ba45f3ad33">core_util_atomic_incr_u32</a> (volatile uint32_t *valuePtr, uint32_t delta)</td></tr>
<tr class="memdesc:ga4a9fd9661ae1db338cd776ba45f3ad33"><td class="mdescLeft"> </td><td class="mdescRight">Atomic increment.  <a href="#ga4a9fd9661ae1db338cd776ba45f3ad33">More...</a><br/></td></tr>
<tr class="separator:ga4a9fd9661ae1db338cd776ba45f3ad33"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga1da475be0bf8e7d9e7cd16177e3d13a5"><td align="right" class="memItemLeft" valign="top">uint64_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga1da475be0bf8e7d9e7cd16177e3d13a5">core_util_atomic_incr_u64</a> (volatile uint64_t *valuePtr, uint64_t delta)</td></tr>
<tr class="memdesc:ga1da475be0bf8e7d9e7cd16177e3d13a5"><td class="mdescLeft"> </td><td class="mdescRight">Atomic increment.  <a href="#ga1da475be0bf8e7d9e7cd16177e3d13a5">More...</a><br/></td></tr>
<tr class="separator:ga1da475be0bf8e7d9e7cd16177e3d13a5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad991d615f9643f15f883e6c4638fe31e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad991d615f9643f15f883e6c4638fe31e">core_util_atomic_incr_s8</a> (volatile int8_t *valuePtr, int8_t delta)</td></tr>
<tr class="memdesc:gad991d615f9643f15f883e6c4638fe31e"><td class="mdescLeft"> </td><td class="mdescRight">Atomic increment.  <a href="#gad991d615f9643f15f883e6c4638fe31e">More...</a><br/></td></tr>
<tr class="separator:gad991d615f9643f15f883e6c4638fe31e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaf71073f46116c910e80c0c4c7409b995"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaf71073f46116c910e80c0c4c7409b995">core_util_atomic_incr_s16</a> (volatile int16_t *valuePtr, int16_t delta)</td></tr>
<tr class="memdesc:gaf71073f46116c910e80c0c4c7409b995"><td class="mdescLeft"> </td><td class="mdescRight">Atomic increment.  <a href="#gaf71073f46116c910e80c0c4c7409b995">More...</a><br/></td></tr>
<tr class="separator:gaf71073f46116c910e80c0c4c7409b995"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaad1b7864af7323246bd38768aff11cf8"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaad1b7864af7323246bd38768aff11cf8">core_util_atomic_incr_s32</a> (volatile int32_t *valuePtr, int32_t delta)</td></tr>
<tr class="memdesc:gaad1b7864af7323246bd38768aff11cf8"><td class="mdescLeft"> </td><td class="mdescRight">Atomic increment.  <a href="#gaad1b7864af7323246bd38768aff11cf8">More...</a><br/></td></tr>
<tr class="separator:gaad1b7864af7323246bd38768aff11cf8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad8058a48a1ddde0bfd1900f9fc789eca"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad8058a48a1ddde0bfd1900f9fc789eca">core_util_atomic_incr_s64</a> (volatile int64_t *valuePtr, int64_t delta)</td></tr>
<tr class="memdesc:gad8058a48a1ddde0bfd1900f9fc789eca"><td class="mdescLeft"> </td><td class="mdescRight">Atomic increment.  <a href="#gad8058a48a1ddde0bfd1900f9fc789eca">More...</a><br/></td></tr>
<tr class="separator:gad8058a48a1ddde0bfd1900f9fc789eca"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga03870912d33e44a87e0ac156ba4376f6"><td align="right" class="memItemLeft" valign="top">void * </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga03870912d33e44a87e0ac156ba4376f6">core_util_atomic_incr_ptr</a> (void *volatile *valuePtr, ptrdiff_t delta)</td></tr>
<tr class="memdesc:ga03870912d33e44a87e0ac156ba4376f6"><td class="mdescLeft"> </td><td class="mdescRight">Atomic increment.  <a href="#ga03870912d33e44a87e0ac156ba4376f6">More...</a><br/></td></tr>
<tr class="separator:ga03870912d33e44a87e0ac156ba4376f6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga22c32f3db5d87ca5ba9661f9efbaa205"><td align="right" class="memItemLeft" valign="top">uint8_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga22c32f3db5d87ca5ba9661f9efbaa205">core_util_atomic_decr_u8</a> (volatile uint8_t *valuePtr, uint8_t delta)</td></tr>
<tr class="memdesc:ga22c32f3db5d87ca5ba9661f9efbaa205"><td class="mdescLeft"> </td><td class="mdescRight">Atomic decrement.  <a href="#ga22c32f3db5d87ca5ba9661f9efbaa205">More...</a><br/></td></tr>
<tr class="separator:ga22c32f3db5d87ca5ba9661f9efbaa205"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga732744dc1479c273c7f096117a92ff83"><td align="right" class="memItemLeft" valign="top">uint16_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga732744dc1479c273c7f096117a92ff83">core_util_atomic_decr_u16</a> (volatile uint16_t *valuePtr, uint16_t delta)</td></tr>
<tr class="memdesc:ga732744dc1479c273c7f096117a92ff83"><td class="mdescLeft"> </td><td class="mdescRight">Atomic decrement.  <a href="#ga732744dc1479c273c7f096117a92ff83">More...</a><br/></td></tr>
<tr class="separator:ga732744dc1479c273c7f096117a92ff83"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaa5cff540da859622ef0fce52f2c25bc6"><td align="right" class="memItemLeft" valign="top">uint32_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaa5cff540da859622ef0fce52f2c25bc6">core_util_atomic_decr_u32</a> (volatile uint32_t *valuePtr, uint32_t delta)</td></tr>
<tr class="memdesc:gaa5cff540da859622ef0fce52f2c25bc6"><td class="mdescLeft"> </td><td class="mdescRight">Atomic decrement.  <a href="#gaa5cff540da859622ef0fce52f2c25bc6">More...</a><br/></td></tr>
<tr class="separator:gaa5cff540da859622ef0fce52f2c25bc6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad40c29bee47dc525faefb7544cce2ac0"><td align="right" class="memItemLeft" valign="top">uint64_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad40c29bee47dc525faefb7544cce2ac0">core_util_atomic_decr_u64</a> (volatile uint64_t *valuePtr, uint64_t delta)</td></tr>
<tr class="memdesc:gad40c29bee47dc525faefb7544cce2ac0"><td class="mdescLeft"> </td><td class="mdescRight">Atomic decrement.  <a href="#gad40c29bee47dc525faefb7544cce2ac0">More...</a><br/></td></tr>
<tr class="separator:gad40c29bee47dc525faefb7544cce2ac0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gadeb322baa1bd668947e5f0bfd3134283"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gadeb322baa1bd668947e5f0bfd3134283">core_util_atomic_decr_s8</a> (volatile int8_t *valuePtr, int8_t delta)</td></tr>
<tr class="memdesc:gadeb322baa1bd668947e5f0bfd3134283"><td class="mdescLeft"> </td><td class="mdescRight">Atomic decrement.  <a href="#gadeb322baa1bd668947e5f0bfd3134283">More...</a><br/></td></tr>
<tr class="separator:gadeb322baa1bd668947e5f0bfd3134283"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga752f3c2b1a007fb57340d827087c7acf"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga752f3c2b1a007fb57340d827087c7acf">core_util_atomic_decr_s16</a> (volatile int16_t *valuePtr, int16_t delta)</td></tr>
<tr class="memdesc:ga752f3c2b1a007fb57340d827087c7acf"><td class="mdescLeft"> </td><td class="mdescRight">Atomic decrement.  <a href="#ga752f3c2b1a007fb57340d827087c7acf">More...</a><br/></td></tr>
<tr class="separator:ga752f3c2b1a007fb57340d827087c7acf"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga89ffa4563fded0662921120ec752c4e9"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga89ffa4563fded0662921120ec752c4e9">core_util_atomic_decr_s32</a> (volatile int32_t *valuePtr, int32_t delta)</td></tr>
<tr class="memdesc:ga89ffa4563fded0662921120ec752c4e9"><td class="mdescLeft"> </td><td class="mdescRight">Atomic decrement.  <a href="#ga89ffa4563fded0662921120ec752c4e9">More...</a><br/></td></tr>
<tr class="separator:ga89ffa4563fded0662921120ec752c4e9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga1aded12e7bbd8250c0f9392617141829"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga1aded12e7bbd8250c0f9392617141829">core_util_atomic_decr_s64</a> (volatile int64_t *valuePtr, int64_t delta)</td></tr>
<tr class="memdesc:ga1aded12e7bbd8250c0f9392617141829"><td class="mdescLeft"> </td><td class="mdescRight">Atomic decrement.  <a href="#ga1aded12e7bbd8250c0f9392617141829">More...</a><br/></td></tr>
<tr class="separator:ga1aded12e7bbd8250c0f9392617141829"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaa9033f801e7969c923ed6719fdd5eb1c"><td align="right" class="memItemLeft" valign="top">void * </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaa9033f801e7969c923ed6719fdd5eb1c">core_util_atomic_decr_ptr</a> (void *volatile *valuePtr, ptrdiff_t delta)</td></tr>
<tr class="memdesc:gaa9033f801e7969c923ed6719fdd5eb1c"><td class="mdescLeft"> </td><td class="mdescRight">Atomic decrement.  <a href="#gaa9033f801e7969c923ed6719fdd5eb1c">More...</a><br/></td></tr>
<tr class="separator:gaa9033f801e7969c923ed6719fdd5eb1c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gafc7672b3ff5038e7e408a79b2d367d85"><td align="right" class="memItemLeft" valign="top">uint8_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gafc7672b3ff5038e7e408a79b2d367d85">core_util_atomic_fetch_add_u8</a> (volatile uint8_t *valuePtr, uint8_t arg)</td></tr>
<tr class="memdesc:gafc7672b3ff5038e7e408a79b2d367d85"><td class="mdescLeft"> </td><td class="mdescRight">Atomic add.  <a href="#gafc7672b3ff5038e7e408a79b2d367d85">More...</a><br/></td></tr>
<tr class="separator:gafc7672b3ff5038e7e408a79b2d367d85"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga651ae50190ea63b037e38c1e3d058f62"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga651ae50190ea63b037e38c1e3d058f62">core_util_atomic_fetch_add_explicit_u8</a> (volatile uint8_t *valuePtr, uint8_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga651ae50190ea63b037e38c1e3d058f62"><td class="mdescLeft"> </td><td class="mdescRight">Atomic add.  <a href="#ga651ae50190ea63b037e38c1e3d058f62">More...</a><br/></td></tr>
<tr class="separator:ga651ae50190ea63b037e38c1e3d058f62"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga2891e6f81e0f7753001610fcf27d1a14"><td align="right" class="memItemLeft" valign="top">uint16_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga2891e6f81e0f7753001610fcf27d1a14">core_util_atomic_fetch_add_u16</a> (volatile uint16_t *valuePtr, uint16_t arg)</td></tr>
<tr class="memdesc:ga2891e6f81e0f7753001610fcf27d1a14"><td class="mdescLeft"> </td><td class="mdescRight">Atomic add.  <a href="#ga2891e6f81e0f7753001610fcf27d1a14">More...</a><br/></td></tr>
<tr class="separator:ga2891e6f81e0f7753001610fcf27d1a14"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga9b1fe9a8547ec4ba9be99695c2d10688"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga9b1fe9a8547ec4ba9be99695c2d10688">core_util_atomic_fetch_add_explicit_u16</a> (volatile uint16_t *valuePtr, uint16_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga9b1fe9a8547ec4ba9be99695c2d10688"><td class="mdescLeft"> </td><td class="mdescRight">Atomic add.  <a href="#ga9b1fe9a8547ec4ba9be99695c2d10688">More...</a><br/></td></tr>
<tr class="separator:ga9b1fe9a8547ec4ba9be99695c2d10688"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga8433a277473c8be2ecf2636b215482a4"><td align="right" class="memItemLeft" valign="top">uint32_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga8433a277473c8be2ecf2636b215482a4">core_util_atomic_fetch_add_u32</a> (volatile uint32_t *valuePtr, uint32_t arg)</td></tr>
<tr class="memdesc:ga8433a277473c8be2ecf2636b215482a4"><td class="mdescLeft"> </td><td class="mdescRight">Atomic add.  <a href="#ga8433a277473c8be2ecf2636b215482a4">More...</a><br/></td></tr>
<tr class="separator:ga8433a277473c8be2ecf2636b215482a4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga6e2cf84841529895574591de06da0a81"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga6e2cf84841529895574591de06da0a81">core_util_atomic_fetch_add_explicit_u32</a> (volatile uint32_t *valuePtr, uint32_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga6e2cf84841529895574591de06da0a81"><td class="mdescLeft"> </td><td class="mdescRight">Atomic add.  <a href="#ga6e2cf84841529895574591de06da0a81">More...</a><br/></td></tr>
<tr class="separator:ga6e2cf84841529895574591de06da0a81"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaccdbfedfdbdad88c8f18caf0a3212f9b"><td align="right" class="memItemLeft" valign="top">uint64_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaccdbfedfdbdad88c8f18caf0a3212f9b">core_util_atomic_fetch_add_u64</a> (volatile uint64_t *valuePtr, uint64_t arg)</td></tr>
<tr class="memdesc:gaccdbfedfdbdad88c8f18caf0a3212f9b"><td class="mdescLeft"> </td><td class="mdescRight">Atomic add.  <a href="#gaccdbfedfdbdad88c8f18caf0a3212f9b">More...</a><br/></td></tr>
<tr class="separator:gaccdbfedfdbdad88c8f18caf0a3212f9b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga52a5a54967b6603caad8a7013b5603d4"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga52a5a54967b6603caad8a7013b5603d4">core_util_atomic_fetch_add_explicit_u64</a> (volatile uint64_t *valuePtr, uint64_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga52a5a54967b6603caad8a7013b5603d4"><td class="mdescLeft"> </td><td class="mdescRight">Atomic add.  <a href="#ga52a5a54967b6603caad8a7013b5603d4">More...</a><br/></td></tr>
<tr class="separator:ga52a5a54967b6603caad8a7013b5603d4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gab749485f59e3e2d83e62ee565aeca6f5"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gab749485f59e3e2d83e62ee565aeca6f5">core_util_atomic_fetch_add_s8</a> (volatile int8_t *valuePtr, int8_t arg)</td></tr>
<tr class="memdesc:gab749485f59e3e2d83e62ee565aeca6f5"><td class="mdescLeft"> </td><td class="mdescRight">Atomic add.  <a href="#gab749485f59e3e2d83e62ee565aeca6f5">More...</a><br/></td></tr>
<tr class="separator:gab749485f59e3e2d83e62ee565aeca6f5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad4d95c74bb5c805196eb6f001704474e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad4d95c74bb5c805196eb6f001704474e">core_util_atomic_fetch_add_explicit_s8</a> (volatile int8_t *valuePtr, int8_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gad4d95c74bb5c805196eb6f001704474e"><td class="mdescLeft"> </td><td class="mdescRight">Atomic add.  <a href="#gad4d95c74bb5c805196eb6f001704474e">More...</a><br/></td></tr>
<tr class="separator:gad4d95c74bb5c805196eb6f001704474e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gadacb556c12ab10eb1bac2ce28d837415"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gadacb556c12ab10eb1bac2ce28d837415">core_util_atomic_fetch_add_s16</a> (volatile int16_t *valuePtr, int16_t arg)</td></tr>
<tr class="memdesc:gadacb556c12ab10eb1bac2ce28d837415"><td class="mdescLeft"> </td><td class="mdescRight">Atomic add.  <a href="#gadacb556c12ab10eb1bac2ce28d837415">More...</a><br/></td></tr>
<tr class="separator:gadacb556c12ab10eb1bac2ce28d837415"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaeec6975ddf7e77d74ade6d5157b89224"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaeec6975ddf7e77d74ade6d5157b89224">core_util_atomic_fetch_add_explicit_s16</a> (volatile int16_t *valuePtr, int16_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gaeec6975ddf7e77d74ade6d5157b89224"><td class="mdescLeft"> </td><td class="mdescRight">Atomic add.  <a href="#gaeec6975ddf7e77d74ade6d5157b89224">More...</a><br/></td></tr>
<tr class="separator:gaeec6975ddf7e77d74ade6d5157b89224"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga5ce4cf4be0c038e724bc5be4d03d9026"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga5ce4cf4be0c038e724bc5be4d03d9026">core_util_atomic_fetch_add_s32</a> (volatile int32_t *valuePtr, int32_t arg)</td></tr>
<tr class="memdesc:ga5ce4cf4be0c038e724bc5be4d03d9026"><td class="mdescLeft"> </td><td class="mdescRight">Atomic add.  <a href="#ga5ce4cf4be0c038e724bc5be4d03d9026">More...</a><br/></td></tr>
<tr class="separator:ga5ce4cf4be0c038e724bc5be4d03d9026"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga7e312ade8a7e075e99b146628909800c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga7e312ade8a7e075e99b146628909800c">core_util_atomic_fetch_add_explicit_s32</a> (volatile int32_t *valuePtr, int32_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga7e312ade8a7e075e99b146628909800c"><td class="mdescLeft"> </td><td class="mdescRight">Atomic add.  <a href="#ga7e312ade8a7e075e99b146628909800c">More...</a><br/></td></tr>
<tr class="separator:ga7e312ade8a7e075e99b146628909800c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga71166f17a0453072cb2a53c9b2c70b50"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga71166f17a0453072cb2a53c9b2c70b50">core_util_atomic_fetch_add_s64</a> (volatile int64_t *valuePtr, int64_t arg)</td></tr>
<tr class="memdesc:ga71166f17a0453072cb2a53c9b2c70b50"><td class="mdescLeft"> </td><td class="mdescRight">Atomic add.  <a href="#ga71166f17a0453072cb2a53c9b2c70b50">More...</a><br/></td></tr>
<tr class="separator:ga71166f17a0453072cb2a53c9b2c70b50"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga529c15151f84f8d992f0b7b73b89114c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga529c15151f84f8d992f0b7b73b89114c">core_util_atomic_fetch_add_explicit_s64</a> (volatile int64_t *valuePtr, int64_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga529c15151f84f8d992f0b7b73b89114c"><td class="mdescLeft"> </td><td class="mdescRight">Atomic add.  <a href="#ga529c15151f84f8d992f0b7b73b89114c">More...</a><br/></td></tr>
<tr class="separator:ga529c15151f84f8d992f0b7b73b89114c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga0c9943d450c01728945ccaf1a252a0a8"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void * </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga0c9943d450c01728945ccaf1a252a0a8">core_util_atomic_fetch_add_ptr</a> (void *volatile *valuePtr, ptrdiff_t arg)</td></tr>
<tr class="memdesc:ga0c9943d450c01728945ccaf1a252a0a8"><td class="mdescLeft"> </td><td class="mdescRight">Atomic add.  <a href="#ga0c9943d450c01728945ccaf1a252a0a8">More...</a><br/></td></tr>
<tr class="separator:ga0c9943d450c01728945ccaf1a252a0a8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga9a541eb135e51a77202895c4871775d6"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void * </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga9a541eb135e51a77202895c4871775d6">core_util_atomic_fetch_add_explicit_ptr</a> (void *volatile *valuePtr, ptrdiff_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga9a541eb135e51a77202895c4871775d6"><td class="mdescLeft"> </td><td class="mdescRight">Atomic add.  <a href="#ga9a541eb135e51a77202895c4871775d6">More...</a><br/></td></tr>
<tr class="separator:ga9a541eb135e51a77202895c4871775d6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gacdd384cefb5b5c96e336c280af3d9334"><td align="right" class="memItemLeft" valign="top">uint8_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gacdd384cefb5b5c96e336c280af3d9334">core_util_atomic_fetch_sub_u8</a> (volatile uint8_t *valuePtr, uint8_t arg)</td></tr>
<tr class="memdesc:gacdd384cefb5b5c96e336c280af3d9334"><td class="mdescLeft"> </td><td class="mdescRight">Atomic subtract.  <a href="#gacdd384cefb5b5c96e336c280af3d9334">More...</a><br/></td></tr>
<tr class="separator:gacdd384cefb5b5c96e336c280af3d9334"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga0cdf17854e749a41ffb1ef1c9391ccb1"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga0cdf17854e749a41ffb1ef1c9391ccb1">core_util_atomic_fetch_sub_explicit_u8</a> (volatile uint8_t *valuePtr, uint8_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga0cdf17854e749a41ffb1ef1c9391ccb1"><td class="mdescLeft"> </td><td class="mdescRight">Atomic subtract.  <a href="#ga0cdf17854e749a41ffb1ef1c9391ccb1">More...</a><br/></td></tr>
<tr class="separator:ga0cdf17854e749a41ffb1ef1c9391ccb1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga3a8cab6163f0c3971217a0a4b6eedc3f"><td align="right" class="memItemLeft" valign="top">uint16_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga3a8cab6163f0c3971217a0a4b6eedc3f">core_util_atomic_fetch_sub_u16</a> (volatile uint16_t *valuePtr, uint16_t arg)</td></tr>
<tr class="memdesc:ga3a8cab6163f0c3971217a0a4b6eedc3f"><td class="mdescLeft"> </td><td class="mdescRight">Atomic subtract.  <a href="#ga3a8cab6163f0c3971217a0a4b6eedc3f">More...</a><br/></td></tr>
<tr class="separator:ga3a8cab6163f0c3971217a0a4b6eedc3f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaef713cf9e4b240fc9333ae986a64f3ad"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaef713cf9e4b240fc9333ae986a64f3ad">core_util_atomic_fetch_sub_explicit_u16</a> (volatile uint16_t *valuePtr, uint16_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gaef713cf9e4b240fc9333ae986a64f3ad"><td class="mdescLeft"> </td><td class="mdescRight">Atomic subtract.  <a href="#gaef713cf9e4b240fc9333ae986a64f3ad">More...</a><br/></td></tr>
<tr class="separator:gaef713cf9e4b240fc9333ae986a64f3ad"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga6a439187827f741048fc07f4cc6fd0f5"><td align="right" class="memItemLeft" valign="top">uint32_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga6a439187827f741048fc07f4cc6fd0f5">core_util_atomic_fetch_sub_u32</a> (volatile uint32_t *valuePtr, uint32_t arg)</td></tr>
<tr class="memdesc:ga6a439187827f741048fc07f4cc6fd0f5"><td class="mdescLeft"> </td><td class="mdescRight">Atomic subtract.  <a href="#ga6a439187827f741048fc07f4cc6fd0f5">More...</a><br/></td></tr>
<tr class="separator:ga6a439187827f741048fc07f4cc6fd0f5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga6a744e93eda19b361077c2d283f69c11"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga6a744e93eda19b361077c2d283f69c11">core_util_atomic_fetch_sub_explicit_u32</a> (volatile uint32_t *valuePtr, uint32_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga6a744e93eda19b361077c2d283f69c11"><td class="mdescLeft"> </td><td class="mdescRight">Atomic subtract.  <a href="#ga6a744e93eda19b361077c2d283f69c11">More...</a><br/></td></tr>
<tr class="separator:ga6a744e93eda19b361077c2d283f69c11"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga63f7d9554d99b226c04021bf058809e9"><td align="right" class="memItemLeft" valign="top">uint64_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga63f7d9554d99b226c04021bf058809e9">core_util_atomic_fetch_sub_u64</a> (volatile uint64_t *valuePtr, uint64_t arg)</td></tr>
<tr class="memdesc:ga63f7d9554d99b226c04021bf058809e9"><td class="mdescLeft"> </td><td class="mdescRight">Atomic subtract.  <a href="#ga63f7d9554d99b226c04021bf058809e9">More...</a><br/></td></tr>
<tr class="separator:ga63f7d9554d99b226c04021bf058809e9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaf71e00325c1ca7d78bfec53182c972a1"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaf71e00325c1ca7d78bfec53182c972a1">core_util_atomic_fetch_sub_explicit_u64</a> (volatile uint64_t *valuePtr, uint64_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gaf71e00325c1ca7d78bfec53182c972a1"><td class="mdescLeft"> </td><td class="mdescRight">Atomic subtract.  <a href="#gaf71e00325c1ca7d78bfec53182c972a1">More...</a><br/></td></tr>
<tr class="separator:gaf71e00325c1ca7d78bfec53182c972a1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga9b868ca82165d3e1e86ff8cb3cc45878"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga9b868ca82165d3e1e86ff8cb3cc45878">core_util_atomic_fetch_sub_s8</a> (volatile int8_t *valuePtr, int8_t arg)</td></tr>
<tr class="memdesc:ga9b868ca82165d3e1e86ff8cb3cc45878"><td class="mdescLeft"> </td><td class="mdescRight">Atomic subtract.  <a href="#ga9b868ca82165d3e1e86ff8cb3cc45878">More...</a><br/></td></tr>
<tr class="separator:ga9b868ca82165d3e1e86ff8cb3cc45878"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gafc7d33c43f941840f436513972cffdf1"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gafc7d33c43f941840f436513972cffdf1">core_util_atomic_fetch_sub_explicit_s8</a> (volatile int8_t *valuePtr, int8_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gafc7d33c43f941840f436513972cffdf1"><td class="mdescLeft"> </td><td class="mdescRight">Atomic subtract.  <a href="#gafc7d33c43f941840f436513972cffdf1">More...</a><br/></td></tr>
<tr class="separator:gafc7d33c43f941840f436513972cffdf1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga1b1f99cad729bd49aa63c570a968a489"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga1b1f99cad729bd49aa63c570a968a489">core_util_atomic_fetch_sub_s16</a> (volatile int16_t *valuePtr, int16_t arg)</td></tr>
<tr class="memdesc:ga1b1f99cad729bd49aa63c570a968a489"><td class="mdescLeft"> </td><td class="mdescRight">Atomic subtract.  <a href="#ga1b1f99cad729bd49aa63c570a968a489">More...</a><br/></td></tr>
<tr class="separator:ga1b1f99cad729bd49aa63c570a968a489"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga3198e21d50306edeca33e63eb6121613"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga3198e21d50306edeca33e63eb6121613">core_util_atomic_fetch_sub_explicit_s16</a> (volatile int16_t *valuePtr, int16_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga3198e21d50306edeca33e63eb6121613"><td class="mdescLeft"> </td><td class="mdescRight">Atomic subtract.  <a href="#ga3198e21d50306edeca33e63eb6121613">More...</a><br/></td></tr>
<tr class="separator:ga3198e21d50306edeca33e63eb6121613"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaf8dce75d68ca82cb52baeb761d6abee3"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaf8dce75d68ca82cb52baeb761d6abee3">core_util_atomic_fetch_sub_s32</a> (volatile int32_t *valuePtr, int32_t arg)</td></tr>
<tr class="memdesc:gaf8dce75d68ca82cb52baeb761d6abee3"><td class="mdescLeft"> </td><td class="mdescRight">Atomic subtract.  <a href="#gaf8dce75d68ca82cb52baeb761d6abee3">More...</a><br/></td></tr>
<tr class="separator:gaf8dce75d68ca82cb52baeb761d6abee3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga038e3bea482bb48b4d2cec13a568c382"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga038e3bea482bb48b4d2cec13a568c382">core_util_atomic_fetch_sub_explicit_s32</a> (volatile int32_t *valuePtr, int32_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga038e3bea482bb48b4d2cec13a568c382"><td class="mdescLeft"> </td><td class="mdescRight">Atomic subtract.  <a href="#ga038e3bea482bb48b4d2cec13a568c382">More...</a><br/></td></tr>
<tr class="separator:ga038e3bea482bb48b4d2cec13a568c382"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga17bf4f676b1bf6a95e8fd98fd02fe63d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga17bf4f676b1bf6a95e8fd98fd02fe63d">core_util_atomic_fetch_sub_s64</a> (volatile int64_t *valuePtr, int64_t arg)</td></tr>
<tr class="memdesc:ga17bf4f676b1bf6a95e8fd98fd02fe63d"><td class="mdescLeft"> </td><td class="mdescRight">Atomic subtract.  <a href="#ga17bf4f676b1bf6a95e8fd98fd02fe63d">More...</a><br/></td></tr>
<tr class="separator:ga17bf4f676b1bf6a95e8fd98fd02fe63d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga644d915b39e49bf2d83f44d3b5762927"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga644d915b39e49bf2d83f44d3b5762927">core_util_atomic_fetch_sub_explicit_s64</a> (volatile int64_t *valuePtr, int64_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga644d915b39e49bf2d83f44d3b5762927"><td class="mdescLeft"> </td><td class="mdescRight">Atomic subtract.  <a href="#ga644d915b39e49bf2d83f44d3b5762927">More...</a><br/></td></tr>
<tr class="separator:ga644d915b39e49bf2d83f44d3b5762927"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gab5b2387a2b58b06c21e9d937a89621a3"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void * </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gab5b2387a2b58b06c21e9d937a89621a3">core_util_atomic_fetch_sub_ptr</a> (void *volatile *valuePtr, ptrdiff_t arg)</td></tr>
<tr class="memdesc:gab5b2387a2b58b06c21e9d937a89621a3"><td class="mdescLeft"> </td><td class="mdescRight">Atomic subtract.  <a href="#gab5b2387a2b58b06c21e9d937a89621a3">More...</a><br/></td></tr>
<tr class="separator:gab5b2387a2b58b06c21e9d937a89621a3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaac30a3c89166145ddd209d24336e671a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void * </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaac30a3c89166145ddd209d24336e671a">core_util_atomic_fetch_sub_explicit_ptr</a> (void *volatile *valuePtr, ptrdiff_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gaac30a3c89166145ddd209d24336e671a"><td class="mdescLeft"> </td><td class="mdescRight">Atomic subtract.  <a href="#gaac30a3c89166145ddd209d24336e671a">More...</a><br/></td></tr>
<tr class="separator:gaac30a3c89166145ddd209d24336e671a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gac71103feba0ddbe9bee54759e3d1ef50"><td align="right" class="memItemLeft" valign="top">uint8_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gac71103feba0ddbe9bee54759e3d1ef50">core_util_atomic_fetch_and_u8</a> (volatile uint8_t *valuePtr, uint8_t arg)</td></tr>
<tr class="memdesc:gac71103feba0ddbe9bee54759e3d1ef50"><td class="mdescLeft"> </td><td class="mdescRight">Atomic bitwise and.  <a href="#gac71103feba0ddbe9bee54759e3d1ef50">More...</a><br/></td></tr>
<tr class="separator:gac71103feba0ddbe9bee54759e3d1ef50"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga118df0bb30ca68d2be8c084be472289b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga118df0bb30ca68d2be8c084be472289b">core_util_atomic_fetch_and_explicit_u8</a> (volatile uint8_t *valuePtr, uint8_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga118df0bb30ca68d2be8c084be472289b"><td class="mdescLeft"> </td><td class="mdescRight">Atomic bitwise and.  <a href="#ga118df0bb30ca68d2be8c084be472289b">More...</a><br/></td></tr>
<tr class="separator:ga118df0bb30ca68d2be8c084be472289b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga0503c7ae8ed7e9105c9827bf564b2af6"><td align="right" class="memItemLeft" valign="top">uint16_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga0503c7ae8ed7e9105c9827bf564b2af6">core_util_atomic_fetch_and_u16</a> (volatile uint16_t *valuePtr, uint16_t arg)</td></tr>
<tr class="memdesc:ga0503c7ae8ed7e9105c9827bf564b2af6"><td class="mdescLeft"> </td><td class="mdescRight">Atomic bitwise and.  <a href="#ga0503c7ae8ed7e9105c9827bf564b2af6">More...</a><br/></td></tr>
<tr class="separator:ga0503c7ae8ed7e9105c9827bf564b2af6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaeb2f48d1bb656d61c0dc92f255c6f21a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaeb2f48d1bb656d61c0dc92f255c6f21a">core_util_atomic_fetch_and_explicit_u16</a> (volatile uint16_t *valuePtr, uint16_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gaeb2f48d1bb656d61c0dc92f255c6f21a"><td class="mdescLeft"> </td><td class="mdescRight">Atomic bitwise and.  <a href="#gaeb2f48d1bb656d61c0dc92f255c6f21a">More...</a><br/></td></tr>
<tr class="separator:gaeb2f48d1bb656d61c0dc92f255c6f21a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaa578cdd3776051931ada26258029733e"><td align="right" class="memItemLeft" valign="top">uint32_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaa578cdd3776051931ada26258029733e">core_util_atomic_fetch_and_u32</a> (volatile uint32_t *valuePtr, uint32_t arg)</td></tr>
<tr class="memdesc:gaa578cdd3776051931ada26258029733e"><td class="mdescLeft"> </td><td class="mdescRight">Atomic bitwise and.  <a href="#gaa578cdd3776051931ada26258029733e">More...</a><br/></td></tr>
<tr class="separator:gaa578cdd3776051931ada26258029733e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga6169b1a76622a0260d8ce24f2a27a071"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga6169b1a76622a0260d8ce24f2a27a071">core_util_atomic_fetch_and_explicit_u32</a> (volatile uint32_t *valuePtr, uint32_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga6169b1a76622a0260d8ce24f2a27a071"><td class="mdescLeft"> </td><td class="mdescRight">Atomic bitwise and.  <a href="#ga6169b1a76622a0260d8ce24f2a27a071">More...</a><br/></td></tr>
<tr class="separator:ga6169b1a76622a0260d8ce24f2a27a071"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gacf9ca48255c2fb18551881f37b86f004"><td align="right" class="memItemLeft" valign="top">uint64_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gacf9ca48255c2fb18551881f37b86f004">core_util_atomic_fetch_and_u64</a> (volatile uint64_t *valuePtr, uint64_t arg)</td></tr>
<tr class="memdesc:gacf9ca48255c2fb18551881f37b86f004"><td class="mdescLeft"> </td><td class="mdescRight">Atomic bitwise and.  <a href="#gacf9ca48255c2fb18551881f37b86f004">More...</a><br/></td></tr>
<tr class="separator:gacf9ca48255c2fb18551881f37b86f004"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gac2969415714af3a77fbb565e78328a4f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gac2969415714af3a77fbb565e78328a4f">core_util_atomic_fetch_and_explicit_u64</a> (volatile uint64_t *valuePtr, uint64_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gac2969415714af3a77fbb565e78328a4f"><td class="mdescLeft"> </td><td class="mdescRight">Atomic bitwise and.  <a href="#gac2969415714af3a77fbb565e78328a4f">More...</a><br/></td></tr>
<tr class="separator:gac2969415714af3a77fbb565e78328a4f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad9a6253c2c2c213f10a8238ac68f834f"><td align="right" class="memItemLeft" valign="top">uint8_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad9a6253c2c2c213f10a8238ac68f834f">core_util_atomic_fetch_or_u8</a> (volatile uint8_t *valuePtr, uint8_t arg)</td></tr>
<tr class="memdesc:gad9a6253c2c2c213f10a8238ac68f834f"><td class="mdescLeft"> </td><td class="mdescRight">Atomic bitwise inclusive or.  <a href="#gad9a6253c2c2c213f10a8238ac68f834f">More...</a><br/></td></tr>
<tr class="separator:gad9a6253c2c2c213f10a8238ac68f834f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga19a483c3c606c7a95e539c269937b3fa"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga19a483c3c606c7a95e539c269937b3fa">core_util_atomic_fetch_or_explicit_u8</a> (volatile uint8_t *valuePtr, uint8_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga19a483c3c606c7a95e539c269937b3fa"><td class="mdescLeft"> </td><td class="mdescRight">Atomic bitwise inclusive or.  <a href="#ga19a483c3c606c7a95e539c269937b3fa">More...</a><br/></td></tr>
<tr class="separator:ga19a483c3c606c7a95e539c269937b3fa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga5171ff450449f9ec9e0cb58b5586aa43"><td align="right" class="memItemLeft" valign="top">uint16_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga5171ff450449f9ec9e0cb58b5586aa43">core_util_atomic_fetch_or_u16</a> (volatile uint16_t *valuePtr, uint16_t arg)</td></tr>
<tr class="memdesc:ga5171ff450449f9ec9e0cb58b5586aa43"><td class="mdescLeft"> </td><td class="mdescRight">Atomic bitwise inclusive or.  <a href="#ga5171ff450449f9ec9e0cb58b5586aa43">More...</a><br/></td></tr>
<tr class="separator:ga5171ff450449f9ec9e0cb58b5586aa43"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaffa1ebeb601da04d37d5e7170e52505d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaffa1ebeb601da04d37d5e7170e52505d">core_util_atomic_fetch_or_explicit_u16</a> (volatile uint16_t *valuePtr, uint16_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gaffa1ebeb601da04d37d5e7170e52505d"><td class="mdescLeft"> </td><td class="mdescRight">Atomic bitwise inclusive or.  <a href="#gaffa1ebeb601da04d37d5e7170e52505d">More...</a><br/></td></tr>
<tr class="separator:gaffa1ebeb601da04d37d5e7170e52505d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad20c7d38345c87afbbc1de568c4a2ea0"><td align="right" class="memItemLeft" valign="top">uint32_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad20c7d38345c87afbbc1de568c4a2ea0">core_util_atomic_fetch_or_u32</a> (volatile uint32_t *valuePtr, uint32_t arg)</td></tr>
<tr class="memdesc:gad20c7d38345c87afbbc1de568c4a2ea0"><td class="mdescLeft"> </td><td class="mdescRight">Atomic bitwise inclusive or.  <a href="#gad20c7d38345c87afbbc1de568c4a2ea0">More...</a><br/></td></tr>
<tr class="separator:gad20c7d38345c87afbbc1de568c4a2ea0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga987adeb2ae9c2db2551a61aa4b426df2"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga987adeb2ae9c2db2551a61aa4b426df2">core_util_atomic_fetch_or_explicit_u32</a> (volatile uint32_t *valuePtr, uint32_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga987adeb2ae9c2db2551a61aa4b426df2"><td class="mdescLeft"> </td><td class="mdescRight">Atomic bitwise inclusive or.  <a href="#ga987adeb2ae9c2db2551a61aa4b426df2">More...</a><br/></td></tr>
<tr class="separator:ga987adeb2ae9c2db2551a61aa4b426df2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaa8c5f724d821fa01783eeb9f9b6654bc"><td align="right" class="memItemLeft" valign="top">uint64_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaa8c5f724d821fa01783eeb9f9b6654bc">core_util_atomic_fetch_or_u64</a> (volatile uint64_t *valuePtr, uint64_t arg)</td></tr>
<tr class="memdesc:gaa8c5f724d821fa01783eeb9f9b6654bc"><td class="mdescLeft"> </td><td class="mdescRight">Atomic bitwise inclusive or.  <a href="#gaa8c5f724d821fa01783eeb9f9b6654bc">More...</a><br/></td></tr>
<tr class="separator:gaa8c5f724d821fa01783eeb9f9b6654bc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga7733cc83af1260afd5484d9f8ab64a52"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga7733cc83af1260afd5484d9f8ab64a52">core_util_atomic_fetch_or_explicit_u64</a> (volatile uint64_t *valuePtr, uint64_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga7733cc83af1260afd5484d9f8ab64a52"><td class="mdescLeft"> </td><td class="mdescRight">Atomic bitwise inclusive or.  <a href="#ga7733cc83af1260afd5484d9f8ab64a52">More...</a><br/></td></tr>
<tr class="separator:ga7733cc83af1260afd5484d9f8ab64a52"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gacf176a784cfb5373edfc0c729cf3f528"><td align="right" class="memItemLeft" valign="top">uint8_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gacf176a784cfb5373edfc0c729cf3f528">core_util_atomic_fetch_xor_u8</a> (volatile uint8_t *valuePtr, uint8_t arg)</td></tr>
<tr class="memdesc:gacf176a784cfb5373edfc0c729cf3f528"><td class="mdescLeft"> </td><td class="mdescRight">Atomic bitwise exclusive or.  <a href="#gacf176a784cfb5373edfc0c729cf3f528">More...</a><br/></td></tr>
<tr class="separator:gacf176a784cfb5373edfc0c729cf3f528"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga7f687c46f29f48b760123770f9cf30f8"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga7f687c46f29f48b760123770f9cf30f8">core_util_atomic_fetch_xor_explicit_u8</a> (volatile uint8_t *valuePtr, uint8_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga7f687c46f29f48b760123770f9cf30f8"><td class="mdescLeft"> </td><td class="mdescRight">Atomic bitwise exclusive or.  <a href="#ga7f687c46f29f48b760123770f9cf30f8">More...</a><br/></td></tr>
<tr class="separator:ga7f687c46f29f48b760123770f9cf30f8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga6e10fc29b3da441a87484046a9d3e41f"><td align="right" class="memItemLeft" valign="top">uint16_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga6e10fc29b3da441a87484046a9d3e41f">core_util_atomic_fetch_xor_u16</a> (volatile uint16_t *valuePtr, uint16_t arg)</td></tr>
<tr class="memdesc:ga6e10fc29b3da441a87484046a9d3e41f"><td class="mdescLeft"> </td><td class="mdescRight">Atomic bitwise exclusive or.  <a href="#ga6e10fc29b3da441a87484046a9d3e41f">More...</a><br/></td></tr>
<tr class="separator:ga6e10fc29b3da441a87484046a9d3e41f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga0cac1f70d86145102d3bf1ceaaed4b54"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga0cac1f70d86145102d3bf1ceaaed4b54">core_util_atomic_fetch_xor_explicit_u16</a> (volatile uint16_t *valuePtr, uint16_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga0cac1f70d86145102d3bf1ceaaed4b54"><td class="mdescLeft"> </td><td class="mdescRight">Atomic bitwise exclusive or.  <a href="#ga0cac1f70d86145102d3bf1ceaaed4b54">More...</a><br/></td></tr>
<tr class="separator:ga0cac1f70d86145102d3bf1ceaaed4b54"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga19cbc4d57409b5eb0ebfc8eee9cd829b"><td align="right" class="memItemLeft" valign="top">uint32_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga19cbc4d57409b5eb0ebfc8eee9cd829b">core_util_atomic_fetch_xor_u32</a> (volatile uint32_t *valuePtr, uint32_t arg)</td></tr>
<tr class="memdesc:ga19cbc4d57409b5eb0ebfc8eee9cd829b"><td class="mdescLeft"> </td><td class="mdescRight">Atomic bitwise exclusive or.  <a href="#ga19cbc4d57409b5eb0ebfc8eee9cd829b">More...</a><br/></td></tr>
<tr class="separator:ga19cbc4d57409b5eb0ebfc8eee9cd829b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga7cf9e78a72b5ed55edcb09240af4e187"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga7cf9e78a72b5ed55edcb09240af4e187">core_util_atomic_fetch_xor_explicit_u32</a> (volatile uint32_t *valuePtr, uint32_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga7cf9e78a72b5ed55edcb09240af4e187"><td class="mdescLeft"> </td><td class="mdescRight">Atomic bitwise exclusive or.  <a href="#ga7cf9e78a72b5ed55edcb09240af4e187">More...</a><br/></td></tr>
<tr class="separator:ga7cf9e78a72b5ed55edcb09240af4e187"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga6b70c15733c776dbcae1a7ee5c056201"><td align="right" class="memItemLeft" valign="top">uint64_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga6b70c15733c776dbcae1a7ee5c056201">core_util_atomic_fetch_xor_u64</a> (volatile uint64_t *valuePtr, uint64_t arg)</td></tr>
<tr class="memdesc:ga6b70c15733c776dbcae1a7ee5c056201"><td class="mdescLeft"> </td><td class="mdescRight">Atomic bitwise exclusive or.  <a href="#ga6b70c15733c776dbcae1a7ee5c056201">More...</a><br/></td></tr>
<tr class="separator:ga6b70c15733c776dbcae1a7ee5c056201"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga3cda9f9445bbace6d20e5ae02bc4a6e8"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga3cda9f9445bbace6d20e5ae02bc4a6e8">core_util_atomic_fetch_xor_explicit_u64</a> (volatile uint64_t *valuePtr, uint64_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga3cda9f9445bbace6d20e5ae02bc4a6e8"><td class="mdescLeft"> </td><td class="mdescRight">Atomic bitwise exclusive or.  <a href="#ga3cda9f9445bbace6d20e5ae02bc4a6e8">More...</a><br/></td></tr>
<tr class="separator:ga3cda9f9445bbace6d20e5ae02bc4a6e8"><td class="memSeparator" colspan="2"> </td></tr>
</tbody></table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Atomic functions function analogously to C11 and C++11 - loads have acquire semantics, stores have release semantics, and atomic operations are sequentially consistent. </p>
<p>Atomicity is enforced both between threads and interrupt handlers. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gaa8f56a572a9d71e864311c431ee1131a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">#define CORE_UTIL_ATOMIC_FLAG_INIT   { 0 }</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Initializer for a <a class="el" href="structcore__util__atomic__flag.html" title="A lock-free, primitive atomic flag. ">core_util_atomic_flag</a>. </p>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span> core_util_atomic_flag in_progress = CORE_UTIL_ATOMIC_FLAG_INIT;</div></div><!-- fragment --> 
<p>Definition at line <a class="el" href="mbed__atomic_8h_source.html#l00127">127</a> of file <a class="el" href="mbed__atomic_8h_source.html">mbed_atomic.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga1060896cc90d691abb7e862cedcdc1b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">typedef struct <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a>  <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A lock-free, primitive atomic flag. </p>
<p>Emulate C11's atomic_flag. The flag is initially in an indeterminate state unless explicitly initialized with CORE_UTIL_ATOMIC_FLAG_INIT. </p>

</div>
</div>
<a class="anchor" id="ga7b145797819135b3b0fff65764f8f234"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">typedef enum <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>  <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Memory order constraints for atomic operations. </p>
<p>Intended semantics are as per C++11. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gaa770b34054b2e54c6bcbd0e9423ecd88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">enum <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Memory order constraints for atomic operations. </p>
<p>Intended semantics are as per C++11. </p>

<p>Definition at line <a class="el" href="mbed__atomic_8h_source.html#l00051">51</a> of file <a class="el" href="mbed__atomic_8h_source.html">mbed_atomic.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gacbf62e56b6923b86006b8f04c57b62e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_bool </td>
          <td>(</td>
          <td class="paramtype">volatile bool * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00829">829</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga5e8c63fcd66c95d8bf4b29d3bc3745bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_bool </td>
          <td>(</td>
          <td class="paramtype">volatile bool * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>failure</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00834">834</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga1c3370fd30e8d1721807aad74a7a4f44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void ** </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void * </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>failure</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00854">854</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gacf63939b06da44cb49a313698053aeb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>failure</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00826">826</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gab572aa9bd7e1ded44f7e6adafb7fe13a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>failure</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00826">826</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad69a97a89c2881c8a9584602e087729e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>failure</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00826">826</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad741471e0981d7dd88e15b7e285d3eb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>failure</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00826">826</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaae923f73dccaad3e5bca9ce02ce47fbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>failure</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga87b4b2754592e31420d1f2b38593b8d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>failure</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga83dc3029317f487bfef8c984ee92cb06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>failure</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga93c9313f1a6be27bed9a3becfde0bee7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>failure</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf9e9cbb15b6cae6154a5f85b483e9358"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool core_util_atomic_cas_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void ** </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void * </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00839">839</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga05d84165af1254189e8c61166ce6b1ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00826">826</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga205688ff94fc52b0652c9399d38ed875"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00826">826</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga6eaa833099480b1cd7f87bb06d93da2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00826">826</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga45910fe69f1d67e6f85654e6b137ad3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00826">826</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga95a29dd5791c91987be0fed54796f08e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool core_util_atomic_cas_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8f1b5edfdabd05b7b2fc400a56e1f9b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool core_util_atomic_cas_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry. </dd></dl>

</div>
</div>
<a class="anchor" id="ga85dd9c14f13cf180e6ecdaea8da6fe11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool core_util_atomic_cas_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3c9ab0fa7ce3b902356e10951e622198"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool core_util_atomic_cas_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry. </dd></dl>

</div>
</div>
<a class="anchor" id="gab1d769b78dbd7f22cbb904d7b768ca45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_bool </td>
          <td>(</td>
          <td class="paramtype">volatile bool * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00871">871</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gadeec7abf1f4deb39287ae36d53e543b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_bool </td>
          <td>(</td>
          <td class="paramtype">volatile bool * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>failure</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00876">876</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga0ad9cc64f6c880a1608a120f41c8ffbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void ** </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void * </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>failure</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00896">896</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga22e345fb761331b2883c063bc6505892"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>failure</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00827">827</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad7686b4293e7ea7bf4950dd5db438c3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>failure</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00827">827</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gae818c803e9b789a9155f2582957284cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>failure</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00827">827</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga6cdb3fd8dfde2fc0b1da38000982bda5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>failure</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00827">827</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga5739219816da159aeaae5096ac4f074d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>failure</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafcc40dbc99cecfa5bac04ebd65c9c0a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>failure</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabb1873cce70f0814a2e65d2bcee84d74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>failure</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8ea57a2b4c9d2958d6d4b9d981db3f63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>failure</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf1778c0381b19ace75e5228c4be8448d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void ** </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void * </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00881">881</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga03b36d178f7b14331ac054ee7de7826e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00827">827</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaeaf10dda44c9c989072495022edae918"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00827">827</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga86d26060ebf45bc519c5e769b369977a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00827">827</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad18413a098f190ede59e9a7dd817480f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00827">827</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga5c40ebfb654b853c353ecf67729b3b02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool core_util_atomic_compare_exchange_weak_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga140f6e8e10012816365a8812a53cf072"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool core_util_atomic_compare_exchange_weak_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaadaa71b8ed5127cb9591fed2cd524b1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool core_util_atomic_compare_exchange_weak_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga80da913bf93f3269a4e35af955f1c660"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool core_util_atomic_compare_exchange_weak_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t * </td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t * </td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa9033f801e7969c923ed6719fdd5eb1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void* core_util_atomic_decr_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t </td>
          <td class="paramname"><em>delta</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic decrement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00984">984</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga752f3c2b1a007fb57340d827087c7acf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_decr_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t </td>
          <td class="paramname"><em>delta</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic decrement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00939">939</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga89ffa4563fded0662921120ec752c4e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_decr_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t </td>
          <td class="paramname"><em>delta</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic decrement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00939">939</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga1aded12e7bbd8250c0f9392617141829"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_decr_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t </td>
          <td class="paramname"><em>delta</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic decrement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00939">939</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gadeb322baa1bd668947e5f0bfd3134283"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_decr_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t </td>
          <td class="paramname"><em>delta</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic decrement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00939">939</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga732744dc1479c273c7f096117a92ff83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint16_t core_util_atomic_decr_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t </td>
          <td class="paramname"><em>delta</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic decrement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa5cff540da859622ef0fce52f2c25bc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint32_t core_util_atomic_decr_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t </td>
          <td class="paramname"><em>delta</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic decrement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value. </dd></dl>

</div>
</div>
<a class="anchor" id="gad40c29bee47dc525faefb7544cce2ac0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint64_t core_util_atomic_decr_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t </td>
          <td class="paramname"><em>delta</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic decrement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga22c32f3db5d87ca5ba9661f9efbaa205"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t core_util_atomic_decr_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t </td>
          <td class="paramname"><em>delta</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic decrement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga085fd843aab08f03815e6925b7b56e35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_exchange_bool </td>
          <td>(</td>
          <td class="paramtype">volatile bool * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic exchange. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00947">947</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga11616204b0007487d3607cfd0036e966"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_exchange_explicit_bool </td>
          <td>(</td>
          <td class="paramtype">volatile bool * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic exchange. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00952">952</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gac2352249f1c125048113668dd898c865"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void* core_util_atomic_exchange_explicit_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void * </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic exchange. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00966">966</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3ff86a2b74166999e50784676e624a9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_exchange_explicit_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic exchange. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00943">943</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaf601f85ee6eff49b498bd02d5355b986"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_exchange_explicit_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic exchange. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00943">943</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga44a1020edbe4b1cfc98cb2470b228c07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_exchange_explicit_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic exchange. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00943">943</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gab32133579ae8ddda64548e209f85a282"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_exchange_explicit_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic exchange. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00943">943</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga09407fb1c3ba1c8518e09b75bc12c6e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t core_util_atomic_exchange_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic exchange. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3cd0876d934c04cf3d097d6048d5b94c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t core_util_atomic_exchange_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic exchange. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab492757a2fc1fdaed58f56877126fc85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t core_util_atomic_exchange_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic exchange. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac7780847ac95064b466ea04bad2a61a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t core_util_atomic_exchange_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic exchange. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga450de337870f36a050d21a4b339b3c67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void* core_util_atomic_exchange_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void * </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic exchange. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00957">957</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad02cc6c6d66a90be4b943dd02a682089"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_exchange_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic exchange. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00937">937</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaa5592ae0738feab92516d27d14c0921b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_exchange_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic exchange. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00937">937</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gac09a70a91d5b50e5e4d18af85f8224de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_exchange_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic exchange. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00937">937</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga9c915efbc7c77b3c72328783af87277d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_exchange_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic exchange. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00937">937</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gae8bff86f0c961096d11b9e4f1b7069ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint16_t core_util_atomic_exchange_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic exchange. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga22e6020a2efeda8cce823c38b8d223d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint32_t core_util_atomic_exchange_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic exchange. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7a53ffc716df9594b56a94fca8ce5cf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint64_t core_util_atomic_exchange_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic exchange. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga59e7a27bc6ea2f39a9ebaad40859bfe5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t core_util_atomic_exchange_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic exchange. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9a541eb135e51a77202895c4871775d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void* core_util_atomic_fetch_add_explicit_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic add. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l01002">1002</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaeec6975ddf7e77d74ade6d5157b89224"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_fetch_add_explicit_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic add. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00944">944</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga7e312ade8a7e075e99b146628909800c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_fetch_add_explicit_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic add. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00944">944</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga529c15151f84f8d992f0b7b73b89114c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_fetch_add_explicit_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic add. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00944">944</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad4d95c74bb5c805196eb6f001704474e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_fetch_add_explicit_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic add. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00944">944</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga9b1fe9a8547ec4ba9be99695c2d10688"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t core_util_atomic_fetch_add_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic add. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6e2cf84841529895574591de06da0a81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t core_util_atomic_fetch_add_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic add. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga52a5a54967b6603caad8a7013b5603d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t core_util_atomic_fetch_add_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic add. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga651ae50190ea63b037e38c1e3d058f62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t core_util_atomic_fetch_add_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic add. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0c9943d450c01728945ccaf1a252a0a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void* core_util_atomic_fetch_add_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic add. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00993">993</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gadacb556c12ab10eb1bac2ce28d837415"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_fetch_add_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic add. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00940">940</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga5ce4cf4be0c038e724bc5be4d03d9026"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_fetch_add_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic add. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00940">940</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga71166f17a0453072cb2a53c9b2c70b50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_fetch_add_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic add. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00940">940</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gab749485f59e3e2d83e62ee565aeca6f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_fetch_add_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic add. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00940">940</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga2891e6f81e0f7753001610fcf27d1a14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint16_t core_util_atomic_fetch_add_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic add. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8433a277473c8be2ecf2636b215482a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint32_t core_util_atomic_fetch_add_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic add. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a class="anchor" id="gaccdbfedfdbdad88c8f18caf0a3212f9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint64_t core_util_atomic_fetch_add_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic add. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a class="anchor" id="gafc7672b3ff5038e7e408a79b2d367d85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t core_util_atomic_fetch_add_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic add. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb2f48d1bb656d61c0dc92f255c6f21a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t core_util_atomic_fetch_and_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic bitwise and. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6169b1a76622a0260d8ce24f2a27a071"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t core_util_atomic_fetch_and_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic bitwise and. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac2969415714af3a77fbb565e78328a4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t core_util_atomic_fetch_and_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic bitwise and. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga118df0bb30ca68d2be8c084be472289b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t core_util_atomic_fetch_and_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic bitwise and. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0503c7ae8ed7e9105c9827bf564b2af6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint16_t core_util_atomic_fetch_and_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic bitwise and. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa578cdd3776051931ada26258029733e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint32_t core_util_atomic_fetch_and_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic bitwise and. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a class="anchor" id="gacf9ca48255c2fb18551881f37b86f004"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint64_t core_util_atomic_fetch_and_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic bitwise and. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a class="anchor" id="gac71103feba0ddbe9bee54759e3d1ef50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t core_util_atomic_fetch_and_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic bitwise and. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a class="anchor" id="gaffa1ebeb601da04d37d5e7170e52505d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t core_util_atomic_fetch_or_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic bitwise inclusive or. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga987adeb2ae9c2db2551a61aa4b426df2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t core_util_atomic_fetch_or_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic bitwise inclusive or. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7733cc83af1260afd5484d9f8ab64a52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t core_util_atomic_fetch_or_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic bitwise inclusive or. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga19a483c3c606c7a95e539c269937b3fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t core_util_atomic_fetch_or_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic bitwise inclusive or. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5171ff450449f9ec9e0cb58b5586aa43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint16_t core_util_atomic_fetch_or_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic bitwise inclusive or. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a class="anchor" id="gad20c7d38345c87afbbc1de568c4a2ea0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint32_t core_util_atomic_fetch_or_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic bitwise inclusive or. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa8c5f724d821fa01783eeb9f9b6654bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint64_t core_util_atomic_fetch_or_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic bitwise inclusive or. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a class="anchor" id="gad9a6253c2c2c213f10a8238ac68f834f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t core_util_atomic_fetch_or_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic bitwise inclusive or. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a class="anchor" id="gaac30a3c89166145ddd209d24336e671a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void* core_util_atomic_fetch_sub_explicit_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic subtract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l01020">1020</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3198e21d50306edeca33e63eb6121613"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_fetch_sub_explicit_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic subtract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00945">945</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga038e3bea482bb48b4d2cec13a568c382"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_fetch_sub_explicit_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic subtract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00945">945</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga644d915b39e49bf2d83f44d3b5762927"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_fetch_sub_explicit_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic subtract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00945">945</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gafc7d33c43f941840f436513972cffdf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_fetch_sub_explicit_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic subtract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00945">945</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaef713cf9e4b240fc9333ae986a64f3ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t core_util_atomic_fetch_sub_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic subtract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6a744e93eda19b361077c2d283f69c11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t core_util_atomic_fetch_sub_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic subtract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf71e00325c1ca7d78bfec53182c972a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t core_util_atomic_fetch_sub_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic subtract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0cdf17854e749a41ffb1ef1c9391ccb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t core_util_atomic_fetch_sub_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic subtract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab5b2387a2b58b06c21e9d937a89621a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void* core_util_atomic_fetch_sub_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic subtract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l01011">1011</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga1b1f99cad729bd49aa63c570a968a489"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_fetch_sub_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic subtract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00941">941</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaf8dce75d68ca82cb52baeb761d6abee3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_fetch_sub_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic subtract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00941">941</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga17bf4f676b1bf6a95e8fd98fd02fe63d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_fetch_sub_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic subtract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00941">941</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga9b868ca82165d3e1e86ff8cb3cc45878"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_fetch_sub_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic subtract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00941">941</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3a8cab6163f0c3971217a0a4b6eedc3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint16_t core_util_atomic_fetch_sub_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic subtract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6a439187827f741048fc07f4cc6fd0f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint32_t core_util_atomic_fetch_sub_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic subtract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga63f7d9554d99b226c04021bf058809e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint64_t core_util_atomic_fetch_sub_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic subtract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a class="anchor" id="gacdd384cefb5b5c96e336c280af3d9334"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t core_util_atomic_fetch_sub_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic subtract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0cac1f70d86145102d3bf1ceaaed4b54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t core_util_atomic_fetch_xor_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic bitwise exclusive or. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7cf9e78a72b5ed55edcb09240af4e187"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t core_util_atomic_fetch_xor_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic bitwise exclusive or. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3cda9f9445bbace6d20e5ae02bc4a6e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t core_util_atomic_fetch_xor_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic bitwise exclusive or. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7f687c46f29f48b760123770f9cf30f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t core_util_atomic_fetch_xor_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t </td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic bitwise exclusive or. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6e10fc29b3da441a87484046a9d3e41f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint16_t core_util_atomic_fetch_xor_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic bitwise exclusive or. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga19cbc4d57409b5eb0ebfc8eee9cd829b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint32_t core_util_atomic_fetch_xor_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic bitwise exclusive or. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6b70c15733c776dbcae1a7ee5c056201"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint64_t core_util_atomic_fetch_xor_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic bitwise exclusive or. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a class="anchor" id="gacf176a784cfb5373edfc0c729cf3f528"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t core_util_atomic_fetch_xor_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t </td>
          <td class="paramname"><em>arg</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic bitwise exclusive or. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a class="anchor" id="gafe5e3f9d2bd9cf92276dacdc3928f4f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_flag_clear </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a> * </td>
          <td class="paramname"><em>flagPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic clear. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">flagPtr</td><td>Target flag being cleared. </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00732">732</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaa1918431bfda711a76ff391ae95f7cdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_flag_clear_explicit </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a> * </td>
          <td class="paramname"><em>flagPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>\ copydoc core_util_atomic_flag_clear </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00739">739</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga38d0898d94b33af23bbbb56e358cdbdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool core_util_atomic_flag_test_and_set </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a> * </td>
          <td class="paramname"><em>flagPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic test and set. </p>
<p>Atomically tests then sets the flag to true, returning the previous value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">flagPtr</td><td>Target flag being tested and set. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value. </dd></dl>

</div>
</div>
<a class="anchor" id="gae873e0a5133bece10fa16b29c43ecc34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_flag_test_and_set_explicit </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a> * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>\ copydoc core_util_atomic_flag_test_and_set </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00691">691</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga03870912d33e44a87e0ac156ba4376f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void* core_util_atomic_incr_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t </td>
          <td class="paramname"><em>delta</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic increment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00975">975</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaf71073f46116c910e80c0c4c7409b995"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_incr_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t </td>
          <td class="paramname"><em>delta</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic increment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00938">938</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaad1b7864af7323246bd38768aff11cf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_incr_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t </td>
          <td class="paramname"><em>delta</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic increment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00938">938</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad8058a48a1ddde0bfd1900f9fc789eca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_incr_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t </td>
          <td class="paramname"><em>delta</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic increment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00938">938</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad991d615f9643f15f883e6c4638fe31e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_incr_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t </td>
          <td class="paramname"><em>delta</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic increment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00938">938</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaf11cb4e3404afe3549a26c852934c8df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint16_t core_util_atomic_incr_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t </td>
          <td class="paramname"><em>delta</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic increment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4a9fd9661ae1db338cd776ba45f3ad33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint32_t core_util_atomic_incr_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t </td>
          <td class="paramname"><em>delta</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic increment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1da475be0bf8e7d9e7cd16177e3d13a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint64_t core_util_atomic_incr_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t </td>
          <td class="paramname"><em>delta</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic increment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7b2738cdb036dd4bf42c8a496107b3c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t core_util_atomic_incr_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t </td>
          <td class="paramname"><em>delta</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic increment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value. </dd></dl>

</div>
</div>
<a class="anchor" id="gaba968e929680be76321b4c639287f968"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_load_bool </td>
          <td>(</td>
          <td class="paramtype">const volatile bool * </td>
          <td class="paramname"><em>valuePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic load. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b4b4c68346a582ed810f5a42f9083e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_load_explicit_bool </td>
          <td>(</td>
          <td class="paramtype">const volatile bool * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic load. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8b245bc78b514cf7c773aee565b2039e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void* core_util_atomic_load_explicit_ptr </td>
          <td>(</td>
          <td class="paramtype">void *const volatile * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic load. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00786">786</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga99004d90211c9e8b31d40a5a86312a8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_load_explicit_s16 </td>
          <td>(</td>
          <td class="paramtype">const volatile int16_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic load. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5a70e0153206702a003de75ffe9b86aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_load_explicit_s32 </td>
          <td>(</td>
          <td class="paramtype">const volatile int32_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic load. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga426c13fee706b73968b19273be5544fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_load_explicit_s64 </td>
          <td>(</td>
          <td class="paramtype">const volatile int64_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__toolchain.html#ga3e0b3dc191a8e64de80be44bbc8d5193">MBED_UNUSED</a> <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic load. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l01038">1038</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga765734c8f47168fbf2e1d3583466df96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_load_explicit_s8 </td>
          <td>(</td>
          <td class="paramtype">const volatile int8_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic load. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2a81771e47a93b508d6ec3f4666b506e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t core_util_atomic_load_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">const volatile uint16_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic load. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa85935b1f85886bd69c028aad61d16ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t core_util_atomic_load_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">const volatile uint32_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic load. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf24e043d3f39b59e5c4e53f7d39558d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t core_util_atomic_load_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">const volatile uint64_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic load. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4b5b21126d2a22858faaf8018b5e66f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t core_util_atomic_load_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">const volatile uint8_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic load. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga424a1a464d29f0afcf7fde90c337803a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void* core_util_atomic_load_ptr </td>
          <td>(</td>
          <td class="paramtype">void *const volatile * </td>
          <td class="paramname"><em>valuePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic load. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00786">786</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga663356b18705a1c4ae4d87643ae239f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_load_s16 </td>
          <td>(</td>
          <td class="paramtype">const volatile int16_t * </td>
          <td class="paramname"><em>valuePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic load. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1994aaeae2efb36b58051da401a95b36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_load_s32 </td>
          <td>(</td>
          <td class="paramtype">const volatile int32_t * </td>
          <td class="paramname"><em>valuePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic load. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga100297ebd80cd21846398c6ad7d81f43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_load_s64 </td>
          <td>(</td>
          <td class="paramtype">const volatile int64_t * </td>
          <td class="paramname"><em>valuePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic load. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00794">794</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaeecfddc99e71a90287f0220e8fd3e206"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_load_s8 </td>
          <td>(</td>
          <td class="paramtype">const volatile int8_t * </td>
          <td class="paramname"><em>valuePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic load. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6b13b1196ed2a63802d7acf2ea08aaf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t core_util_atomic_load_u16 </td>
          <td>(</td>
          <td class="paramtype">const volatile uint16_t * </td>
          <td class="paramname"><em>valuePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic load. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>

</div>
</div>
<a class="anchor" id="gade580faac99dbf59aeda5da1e4c213ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t core_util_atomic_load_u32 </td>
          <td>(</td>
          <td class="paramtype">const volatile uint32_t * </td>
          <td class="paramname"><em>valuePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic load. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>

</div>
</div>
<a class="anchor" id="gae79f750b7b18b9b6c54b9f67c235195f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint64_t core_util_atomic_load_u64 </td>
          <td>(</td>
          <td class="paramtype">const volatile uint64_t * </td>
          <td class="paramname"><em>valuePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic load. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2840954e59468ea85b91e17ca50ad009"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t core_util_atomic_load_u8 </td>
          <td>(</td>
          <td class="paramtype">const volatile uint8_t * </td>
          <td class="paramname"><em>valuePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic load. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4692889cc8d1bd170af962728be04dc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_bool </td>
          <td>(</td>
          <td class="paramtype">volatile bool * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00785">785</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gab9ca948b9322559e941dd359400ae4fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_bool </td>
          <td>(</td>
          <td class="paramtype">volatile bool * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00785">785</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaca4ebe09fe2de1ddc6ce8151baefc991"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void * </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00786">786</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaedd333e4cab3877d64f041e538cff66b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00783">783</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3b27494dba292ef9caa12d164b7a1b9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00784">784</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gade28bd9fce9c1c0f448eab73cb00e460"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga361bc02b02df102a3f3ddf0ae84a9df0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00782">782</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad81d69ed6094e7cd6cfb1f3b729955fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00780">780</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga2960e2d63e4c37c93f202cbb597189a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00781">781</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad54a248229f8606e148c9708c7237334"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaca1cdaf85b894b8bccb88e870577f324"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t </td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td>
          <td class="paramname"><em>order</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00779">779</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaa112a4db89b94efa5f785035415f0d5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void * </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00786">786</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gae67ef75f813610e1bd3804b4cfa22565"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00783">783</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga63d826b01dc7aae7c3a473c349f0ee32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00784">784</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga15431b3da92b29949c1d597f425c7a07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00799">799</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga2024d6b1bd77f35d0bd27b9abeaca252"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00782">782</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga2f38862b163d1a943b28dabfd39fc8ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00780">780</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga981dd31a80f495369723280424a3999e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00781">781</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaaffb39f69f9e80d787404bcdc627bd39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void core_util_atomic_store_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf5c3fa6d415e012c34c7c82056817f29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t * </td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t </td>
          <td class="paramname"><em>desiredValue</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Atomic store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </tbody></table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00779">779</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
</div><!-- contents -->
        
    


        
<footer class="global-footer">
    <ul class="global-footer-media global-footer-row">
        <li>
            <a class="footer-media-icon" title="Twitter" href="https://twitter.com/ArmSoftwareDev">
                <span class="fab fa-twitter-square fa-2x"></span>
                <span class="global-footer-show-on-large-screens">Twitter</span>
            </a>
        </li>
        <li>
            <a class="footer-media-icon" title="YouTube" href="https://www.youtube.com/c/ArmSoftwareDevelopers">
                <span class="fab fa-youtube-square fa-2x"></span>
                <span class="global-footer-show-on-large-screens">YouTube</span>
            </a>
        </li>
        <li>
            <a class="footer-media-icon" title="Forum" href="http://forums.mbed.com/">
                <span class="fas fa-comments fa-2x"></span>
                <span class="global-footer-show-on-large-screens">Forum</span>
            </a>
        </li>
        <li>
            <a class="footer-media-icon" title="Blog" href="http://blog.mbed.com/">
                <span class="fas fa-pen-square fa-2x"></span>
                <span class="global-footer-show-on-large-screens">Blog</span>
            </a>
        </li>
    </ul>

    <div class="global-footer-copyright global-footer-row">
        <div class="copyright-statement">Copyright © <script>document.write(new Date().getFullYear());</script> Arm Limited (or its affiliates).</div>
        <ul class="copyright-links">
            <li><a href="https://os.mbed.com/">Home</a></li>
            <li><a href="https://www.arm.com/company/policies/terms-and-conditions">Website Terms</a></li>
            <li><a href="https://www.arm.com/company/policies/privacy">Privacy</a></li>
            <li><a href="https://www.arm.com/company/policies/cookies">Cookies</a></li>
            <li><a href="http://www.arm.com/company/policies/trademarks">Trademarks</a></li>
        </ul>
    </div>
</footer>



    <div id="cookiemodule">
    <h5>Important Information for this Arm website</h5>
    <div id="cookiecontent">
        <p>
            This site uses cookies to store information on your computer.
            By continuing to use our site, you consent to our cookies.
            If you are not happy with the use of these cookies, please review our
            <a href="https://www.arm.com/company/policies/cookies">Cookie Policy</a>
            to learn how they can be disabled.
            By disabling cookies, some features of the site will not work.
        </p>
        <button id="acceptcookie">Accept and hide this message</button>
    </div>
</div>
<script src="../../../../static/js/cookie_law.js"></script>




    </body>

<!-- Mirrored from os.mbed.com/docs/mbed-os/v6.16/feature-i2c-doxy/group__platform__atomic.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 16 Sep 2024 16:01:05 GMT -->
</html>
